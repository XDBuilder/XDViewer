<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDViewer</title>
    <link rel="stylesheet" href="style.css"> <!-- 외부 CSS 파일 연결 -->
</head>

<body>
    <!-- 지도 표시 영역 -->
    <div id='map'></div>

    <!-- VSCode 스타일 사이드바 -->
    <div id="sidebar">
        <!-- 탭 바 -->
        <div id="tabbar">
            <button class="tab-button active" data-tab="layers" title="레이어">
                ☰
            </button>
        </div>

        <!-- 사이드바 패널 -->
        <div id="sidebar-panel" onmouseout="mouseOverInterface(false);" onmouseover="mouseOverInterface(true);">
            <!-- 레이어 패널 -->
            <div id="layers-panel" class="panel active">
                <div class="panel-header">
                    레이어
                </div>
                <div class="panel-content">
                    <!-- 레이어 열기 버튼 -->
                    <button id="openLayer">레이어 추가</button>

                    <!-- 레이어 아이템들이 추가될 영역 -->
                    <div id="interface"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="geojsonLayerList" class="layerlist" style="margin-bottom: 10px;"></div>

    <script>
        index = 0;

        // 사이드바 탭 토글 기능
        document.addEventListener('DOMContentLoaded', () => {
            const tabButtons = document.querySelectorAll('.tab-button');
            const sidebarPanel = document.getElementById('sidebar-panel');
            const mapElement = document.getElementById('map');
            let currentTab = 'layers';

            // 사이드바 닫기 함수
            function closeSidebar() {
                if (!sidebarPanel.classList.contains('collapsed')) {
                    sidebarPanel.classList.add('collapsed');
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    currentTab = null;
                }
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.getAttribute('data-tab');

                    // 같은 탭을 다시 클릭하면 패널 닫기
                    if (currentTab === tabName && !sidebarPanel.classList.contains('collapsed')) {
                        closeSidebar();
                    } else {
                        // 다른 탭 클릭 시 패널 열기
                        sidebarPanel.classList.remove('collapsed');

                        // 모든 탭 버튼과 패널 비활성화
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));

                        // 선택된 탭 활성화
                        button.classList.add('active');
                        document.getElementById(`${tabName}-panel`).classList.add('active');
                        currentTab = tabName;
                    }
                });
            });

            // 지도 클릭 시 사이드바 닫기
            mapElement.addEventListener('mousedown', (e) => {
                // 사이드바 영역 클릭은 제외
                if (!e.target.closest('#sidebar')) {
                    closeSidebar();
                }
            });

            // 지도 휠(줌) 사용 시 사이드바 닫기
            mapElement.addEventListener('wheel', (e) => {
                closeSidebar();
            });
        });

        // 랜덤 색상 생성 함수
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // 레이어 아이템 드래그 앤 드롭 기능
        let draggedItem = null;

        // 레이어 순서 동기화 함수
        function syncLayerOrder() {
            const container = document.getElementById('interface');
            const items = Array.from(container.children);

            // 각 레이어 아이템의 현재 위치와 layer 객체를 수집
            const layerData = items.map((item, index) => ({
                item: item,
                layer: item._xdLayer,
                layerList: item._xdLayerList,
                currentIndex: index
            })).filter(data => data.layer && data.layerList);

            // 레이어 순서를 DOM 순서에 맞게 재정렬
            // 맨 뒤부터 시작해서 각 레이어를 올바른 위치로 이동
            for (let i = layerData.length - 1; i >= 0; i--) {
                const data = layerData[i];
                // 레이어를 맨 뒤로 보낸 다음, 필요한 만큼 앞으로 이동
                data.layerList.setLayerTopNBottom(data.layer, false); // 맨 뒤로
            }

            // 이제 역순으로 다시 정렬 (맨 앞부터)
            for (let i = 0; i < layerData.length; i++) {
                const data = layerData[i];
                // i번 반복해서 앞으로 이동
                for (let j = 0; j < layerData.length - 1 - i; j++) {
                    data.layerList.setLayerMove(data.layer, true); // 앞으로 이동
                }
            }
        }

        function makeDraggable(layerItem, layer, layerList) {
            // 레이어 객체를 아이템에 저장
            layerItem._xdLayer = layer;
            layerItem._xdLayerList = layerList;

            layerItem.draggable = true;
            layerItem.style.cursor = 'move';

            layerItem.addEventListener('dragstart', (e) => {
                draggedItem = layerItem;
                layerItem.style.opacity = '0.5';
                e.dataTransfer.effectAllowed = 'move';
            });

            layerItem.addEventListener('dragend', (e) => {
                layerItem.style.opacity = '1';
                draggedItem = null;

                // 드래그가 끝나면 레이어 순서 동기화
                syncLayerOrder();
            });

            layerItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                if (draggedItem && draggedItem !== layerItem) {
                    const container = layerItem.parentNode;
                    const items = Array.from(container.children);
                    const draggedIndex = items.indexOf(draggedItem);
                    const targetIndex = items.indexOf(layerItem);

                    if (draggedIndex < targetIndex) {
                        layerItem.after(draggedItem);
                    } else {
                        layerItem.before(draggedItem);
                    }
                }
            });

            layerItem.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        }

        // 파일 처리 함수 (공통 로직)
        function processFilePath(filePath) {
            // 파일 경로에서 file:/// 접두어 제거
            if (filePath.startsWith("file:///")) {
                filePath = filePath.replace("file:///", "");
            } else if (filePath.startsWith("File:///")) {
                filePath = filePath.replace("File:///", "");
            }
            filePath = filePath.replace(/\\/g, '/'); // 역슬래시를 슬래시로 변경

            if (filePath.endsWith('tileset.json')) {
                // tileset.json 파일이면 3DTILES 레이어로 추가
                let layerList = new Module.JSLayerList(true);
                // 상위 폴더명 추출
                let pathParts = filePath.split(/[\\/]/);
                let parentFolder = pathParts.length > 1 ? pathParts[pathParts.length - 2] : '_LAYER_' + index;
                let layer = layerList.createLayer(parentFolder, Module.ELT_3DTILES);
                layer.import3DTiles({
                    url: filePath,
                    autoMove: true,
                    offsetZ: 2.0
                });
                layer.setPointCloudPointSize(2.0); // 포인트 클라우드 크기 설정

                // 새 레이어 UI 생성
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';

                // 체크박스
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    layer.setVisible(checkbox.checked);
                });

                // 레이어 이름
                const label = document.createElement('span');
                label.textContent = parentFolder;
                label.title = parentFolder; // 마우스 오버 시 전체 이름 표시
                label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                label.addEventListener('click', () => {
                    const jsonData = window.electronAPI.readJsonFile(filePath);
                    var trs = jsonData['root']['transform'];
                    var lla = ecefToLla(trs[12], trs[13], trs[14]);
                    Module.getViewCamera().move(new Module.JSVector3D(lla.lonDeg, lla.latDeg, lla.h + 1000), 89.9, 0, 0);
                });

                // x 제거 버튼
                const removeBtn = document.createElement('button');
                removeBtn.textContent = "X";
                removeBtn.addEventListener('click', () => {
                    Module.XDEMapRemoveLayer(label.textContent);
                    layerItem.remove();
                    mouseOverInterface(false);
                });

                // 조립
                layerItem.appendChild(checkbox);
                layerItem.appendChild(label);
                layerItem.appendChild(removeBtn);

                // 드래그 앤 드롭 가능하게 설정
                makeDraggable(layerItem, layer, layerList);

                document.getElementById('interface').appendChild(layerItem);
                index++;
            } else if (filePath.endsWith('.geojson')) {
                loadGeojsonLayer(filePath);
            } else if (filePath.endsWith('.meta')) {
                loadMetaLayer(filePath);
            }
        }

        // Electron에서 파일 경로 수신 시 처리
        window.electronAPI.onFilePathReceived((event, filePaths) => {
            // 여러 파일을 받을 수 있도록 filePaths 배열로 처리
            if (!Array.isArray(filePaths)) {
                filePaths = [filePaths];
            }
            filePaths.forEach(processFilePath);
        });

        // 파일 선택 버튼 클릭 시 메인 프로세스에 파일 선택 요청
        document.getElementById('openLayer').addEventListener('click', async () => {

            window.electronAPI.openFileDialog({
                filters: [
                    { name: 'JSON/GeoJSON Files', extensions: ['json', 'geojson'] },
                    { name: 'Layer', extensions: ['meta'] }
                ],
                properties: ['openFile']
            }); // 메인 프로세스의 파일 선택 다이얼로그 호출
        });

        // 드래그 앤 드롭 기능 추가
        // Document 레벨에서 기본 드래그 동작 방지 (Electron에서 필수)
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        // body 전체에 드래그 앤 드롭 적용
        const dropZone = document.body;

        // dragenter 이벤트 추가
        dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Drag enter detected');
            document.getElementById('map').classList.add('dragover');
        }, false);

        // 드래그 오버 시 기본 동작 방지 및 시각적 피드백
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        // 드래그가 영역을 떠날 때 시각적 피드백 제거
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // 완전히 떠났을 때만 제거 (자식 요소로 이동하는 경우 제외)
            if (e.target === dropZone) {
                console.log('Drag leave detected');
                document.getElementById('map').classList.remove('dragover');
            }
        }, false);

        // 파일 확장자 검증 함수
        function isValidFileType(filePath) {
            const validExtensions = ['.geojson', '.meta'];
            const fileName = filePath.toLowerCase();

            // tileset.json 체크
            if (fileName.endsWith('tileset.json')) {
                return true;
            }

            // 다른 허용 확장자 체크
            return validExtensions.some(ext => fileName.endsWith(ext));
        }

        // 파일 드롭 시 처리
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Drop detected');
            document.getElementById('map').classList.remove('dragover');

            const files = e.dataTransfer.files;
            console.log('Dropped files:', files.length);

            if (files && files.length > 0) {
                let validFileCount = 0;
                let invalidFiles = [];

                // Electron의 webUtils를 사용하여 파일 경로 가져오기
                Array.from(files).forEach(file => {
                    const filePath = window.electronAPI.getPathForFile(file);
                    console.log('File path:', filePath);

                    if (filePath) {
                        // 파일 형식 검증
                        if (isValidFileType(filePath)) {
                            processFilePath(filePath);
                            validFileCount++;
                        } else {
                            invalidFiles.push(file.name);
                        }
                    }
                });

                // 유효하지 않은 파일이 있으면 알림
                if (invalidFiles.length > 0) {
                    alert('지원하지 않는 파일 형식입니다.\n허용된 파일: .geojson, .meta, tileset.json\n\n잘못된 파일:\n' + invalidFiles.join('\n'));
                }

                console.log(`Valid files processed: ${validFileCount}, Invalid files: ${invalidFiles.length}`);
            }
        }, false);

        // 인터페이스 마우스 오버 상태 설정
        function mouseOverInterface(_isOver) {
            if (typeof Module == "object") {
                Module.XDIsMouseOverDiv(_isOver);
            }
        }

        // 창 크기 변경 시 처리
        window.onresize = function (e) {
            if (typeof Module == 'object') {
                if (typeof Module.Resize == 'function') {
                    Module.Resize(window.innerWidth, window.innerHeight); // 모듈 크기 조정
                    Module.XDRenderData(); // 데이터 렌더링
                }
            }
        };

        // XDWorld 모듈 설정
        var Module = {
            locateFile: function (s) {
                return "https://cdn.xdworld.kr/latest/" + s; // 모듈 파일 경로 설정
            },
            postRun: function () {
                Module.initialize({
                    container: document.getElementById("map"), // 지도 컨테이너 설정
                    terrain: {
                        dem: {
                            url: "https://xdworld.vworld.kr",
                            name: "dem",
                            servername: "XDServer3d",
                            encoding: true
                        },
                        image: {
                            url: "https://xdworld.vworld.kr",
                            name: "tile",
                            servername: "XDServer3d"
                        }
                    },
                    worker: {
                        use: true, // 워커 사용 여부
                        path: "./worker/XDWorldWorker.js", // 워커 파일 경로
                        count: 5 // 워커 수
                    },
                    defaultKey: "dJe!e!iaEpHmEpCrD5QpEQf2#FBrdzDmd(BQDQEQDJdaE(iB"
                });
                /*
                                // 기본 타일 레이어 설정
                                var layerSimple = Module.getTileLayerList().createXDServerLayer({
                                    url: "https://xdworld.vworld.kr",
                                    servername: "XDServer3d",
                                    name: "facility_build",
                                    type: 9,
                                    minLevel: 0,
                                    maxLevel: 15
                                });
                                Module.setVisibleRange("facility_build", 3.0, 100000.0); // 가시 범위 설정
                
                                // 간단 모드 설정
                                Module.getMap().setSimpleMode(true);
                                Module.getViewCamera().setLocation(new Module.JSVector3D(126.9, 37.5, 300.0)); // 초기 카메라 위치 설정
                                Module.getViewCamera().setTilt(30); // 카메라 기울기 설정
                */
            }
        };

        // XDWorld 스크립트 동적 로드
        var script = document.createElement('script');
        script.src = "https://cdn.xdworld.kr/latest/XDWorldEM.js";
        document.body.appendChild(script);

        function createPointObjects(layer, features, altitude, color) {
            var layerName = layer.getName();
            var pointIcon = getMarkerIcon(layerName, color, false, 0);

            for (let i = 0; i < features.length; i++) {
                let feature = features[i];
                let coords = feature.geometry.coordinates;
                if (!Array.isArray(coords) || coords.length < 2) continue;
                if (!pointIcon) {
                    console.error("아이콘 생성 실패");
                    return;
                }
                let id = feature.id || "GEOJSON_POINT_" + i;
                let lon = coords[0];
                let lat = coords[1];
                let alt = coords.length >= 3 ? coords[2] : altitude;

                let point = Module.createPoint(id);
                point.setPosition(new Module.JSVector3D(lon, lat, alt + 1.5));
                point.setIcon(pointIcon)


                layer.addObject(point, 0);
            }
            layer.rebuildObjectLayer();
        }

        function createLineObjects(layer, features, altitude, color) {
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                const geometry = feature.geometry;
                if (!geometry || !geometry.coordinates) continue;

                const id = feature.id || `GEOJSON_LINE_${i}`;
                const line = Module.createLineString(id);

                const vertexList = new Module.JSVec3Array();
                const partList = new Module.Collection();

                if (geometry.type === "LineString") {
                    partList.addItem(geometry.coordinates.length);
                    geometry.coordinates.forEach(coord => {
                        const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                        vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                    });
                }
                else if (geometry.type === "MultiLineString") {
                    for (const part of geometry.coordinates) {
                        partList.add(part.length);
                        for (const coord of part) {
                            const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                            vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                        }
                    }
                }
                // 스타일 지정
                var style = new Module.JSPolyLineStyle();
                style.setWidth(3.0);
                style.setColor(new Module.JSColor(255, ...colorStringToRGB(color)));
                line.setStyle(style);

                line.setPartCoordinates(vertexList, partList);
                layer.addObject(line, 0);
            }
            layer.rebuildObjectLayer();
        }

        function createPolygonObjects(layer, features, altitude, color) {
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                const geometry = feature.geometry;
                if (!geometry || !geometry.coordinates) continue;

                const id = feature.id || `GEOJSON_POLY_${i}`;

                if (geometry.type === "Polygon") {
                    createSinglePolygon(id, geometry.coordinates, color, altitude, layer);
                }
                else if (geometry.type === "MultiPolygon") {
                    for (let j = 0; j < geometry.coordinates.length; j++) {
                        const partId = `${id}_part${j}`;
                        createSinglePolygon(partId, geometry.coordinates[j], color, altitude, layer);
                    }
                }
            }
            layer.rebuildObjectLayer();
        }

        function createSinglePolygon(id, rings, color, altitude, layer) {
            const polygon = Module.createPolygon(id);
            const allVertices = new Module.Collection();

            // 외곽선만 추가 (내부 링은 무시)
            const outerRing = rings[0];
            outerRing.forEach(coord => {
                const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                allVertices.add(new Module.JSVector3D(x, y, z + 1.5));
            });

            const style = new Module.JSPolygonStyle();
            style.setFill(true);
            style.setFillColor(new Module.JSColor(255, ...colorStringToRGB(color)));

            polygon.setStyle(style);
            polygon.setCoordinates(allVertices);

            layer.addObject(polygon, 0);
        }

        function colorStringToRGB(rgbaStr) {
            // 예: "rgba(123, 234, 45, 1.0)" → [123, 234, 45]
            const matches = rgbaStr.match(/\d+(\.\d+)?/g);
            if (!matches || matches.length < 3) return [0, 0, 0];
            return [parseInt(matches[0]), parseInt(matches[1]), parseInt(matches[2])];
        }

        function getMarkerIcon(_id, _color, returnDataUrl, type) {
            var canvas = document.createElement('canvas');
            var size = 16;
            canvas.width = size;
            canvas.height = size;

            var ctx = canvas.getContext('2d');

            if (type == 0) {
                // 점
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI, false);
                ctx.fillStyle = _color;
                ctx.fill();
            } else if (type == 1) {
                // 선
                ctx.beginPath();
                ctx.moveTo(0, size / 2);
                ctx.lineTo(size, size / 2);
                ctx.strokeStyle = _color;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // 면
                ctx.beginPath();
                ctx.moveTo(2, 2);
                ctx.lineTo(size - 2, 2);
                ctx.lineTo(size - 2, size - 2);
                ctx.lineTo(2, size - 2);
                ctx.closePath();

                ctx.fillStyle = _color;
                ctx.fill();
                ctx.strokeStyle = "#FFFFFF"; // 테두리 색 (옵션)
                ctx.lineWidth = 1;
                ctx.stroke();
            }


            if (returnDataUrl) {
                return canvas.toDataURL();
            }

            if (Module.getSymbol().insertIcon(_id, ctx.getImageData(0, 0, canvas.width, canvas.height).data, canvas.width, canvas.height)) {
                return Module.getSymbol().getIcon(_id);
            }
            return null;
        }



        function loadGeojsonLayer(filePath) {
            const fileName = filePath.split(/[\/]/).pop().replace('.geojson', '');
            window.electronAPI.readGeoJSON(filePath).then(function (data) {
                if (!data || !data.features || data.features.length === 0) {
                    alert("GeoJSON에 feature가 없습니다.");
                    return;
                }
                const type = data.features[0].geometry.type;
                const layerList = new Module.JSLayerList(true);
                let layer = null;
                switch (type) {
                    case "Point":
                        layer = layerList.createLayer(fileName, Module.ELT_3DPOINT);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        layer = layerList.createLayer(fileName, Module.ELT_3DLINE);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        layer = layerList.createLayer(fileName, Module.ELT_POLYHEDRON);
                        break;
                    default:
                        alert("지원하지 않는 geometry type: " + type);
                        return;
                }
                // 랜더러에서 파싱된 데이터 사용
                const randomColor = 'rgba(' + Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ', 1.0)';
                switch (type) {
                    case "Point":
                        createPointObjects(layer, data.features, 0.0, randomColor);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        createLineObjects(layer, data.features, 0.0, randomColor);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        createPolygonObjects(layer, data.features, 0.0, randomColor);
                        break;
                }
                // 새 레이어 UI 생성
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';

                // 체크박스
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    layer.setVisible(checkbox.checked);
                });

                // geometry 타입에 따른 아이콘
                let iconElement = null;
                if (type === "Point") {
                    // 지도용: getPointMarkerIcon(fileName, randomColor)
                    // 리스트용: getPointMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 0);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '12px';
                    iconElement.style.height = '12px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';
                    //iconElement.innerHTML = `<div style="position:relative;top:7px;left:2px;width:3px;height:3px;background:${randomColor};border-radius:1px;"></div>`;
                } else if (type === "LineString" || type === "MultiLineString") {
                    // 지도용: getLineMarkerIcon(fileName, randomColor)
                    // 리스트용: getLineMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 1);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '12px';
                    iconElement.style.height = '12px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';
                } else if (type === "Polygon" || type === "MultiPolygon") {
                    // 지도용: getPolygonMarkerIcon(fileName, randomColor)
                    // 리스트용: getPolygonMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 2);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '16px';
                    iconElement.style.height = '16px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';                    
                }

                moveToLayer(layer)

                // 레이어 이름
                const label = document.createElement('span');
                label.textContent = fileName;
                label.title = fileName; // 마우스 오버 시 전체 이름 표시
                label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                label.addEventListener('click', () => {
                    moveToLayer(layer)
                });

                // x 제거 버튼
                const removeBtn = document.createElement('button');
                removeBtn.textContent = "X";
                removeBtn.addEventListener('click', () => {
                    Module.XDEMapRemoveLayer(label.textContent);
                    layerItem.remove();
                    mouseOverInterface(false);
                });

                // 조립
                layerItem.appendChild(checkbox);
                if (iconElement) {
                    layerItem.appendChild(iconElement);
                }
                layerItem.appendChild(label);
                layerItem.appendChild(removeBtn);

                // 드래그 앤 드롭 가능하게 설정
                makeDraggable(layerItem, layer, layerList);

                document.getElementById('interface').appendChild(layerItem);
                index++;
            }).catch(err => {
                alert("GeoJSON 파일을 읽을 수 없습니다: " + err);
            });
        }
        function moveToLayer(layer) {
            let obj = layer.indexAtObject(0);
            console.log(obj.position.longitude, obj.position.latitude, obj.position.altitude);
            let cenLon = obj.position.longitude;
            let cenLat = obj.position.latitude;
            let cenAlt = obj.position.altitude;
            Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, cenAlt + 1000), 89.9, 0, 0);

        }
        // ECEF -> Geodetic (lat, lon, h), WGS84
        function ecefToLla(x, y, z) {
            const a = 6378137.0;                 // WGS84 semi-major
            const f = 1 / 298.257223563;         // flattening
            const e2 = f * (2 - f);              // first eccentricity^2

            const lon = Math.atan2(y, x);
            const p = Math.hypot(x, y);
            let lat = Math.atan2(z, p * (1 - e2));
            let N, h, latNew;

            for (let i = 0; i < 10; i++) {
                const sinLat = Math.sin(lat);
                N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                h = p / Math.cos(lat) - N;
                latNew = Math.atan2(z, p * (1 - e2 * N / (N + h)));
                if (Math.abs(lat - latNew) < 1e-12) { lat = latNew; break; }
                lat = latNew;
            }
            N = a / Math.sqrt(1 - e2 * Math.sin(lat) ** 2);
            h = p / Math.cos(lat) - N;

            return {
                latDeg: lat * 180 / Math.PI,
                lonDeg: lon * 180 / Math.PI,
                h
            };
        }
        function loadMetaLayer(filePath) {
            window.electronAPI.readMeta(filePath)
                .then(data => {
                    try {

                        const jsonData = JSON.parse(data);
                        const layerName = jsonData['name'];
                        const layerPath = jsonData['path'];
                        const layerType = jsonData['type'];
                        const minLon = jsonData['area']['min']['lon'];
                        const maxLon = jsonData['area']['max']['lon'];
                        const minLat = jsonData['area']['min']['lat'];
                        const maxLat = jsonData['area']['max']['lat'];
                        const minLv = jsonData['level']['min'];
                        const maxLv = jsonData['level']['max'];
                        let cenLon = (minLon + maxLon) / 2;
                        let cenLat = (minLat + maxLat) / 2;
                        let alt = 1000;
                        let layer = null;
                        let layerList = new Module.JSLayerList(false);
                        let type = null;
                        if (layerType == "ETLT_PNG_IMAGE") {                            
                            type = Module.TILE_LAYER_TYPE_IMAGE;
                            alt = 5000;                            
                        }
                        if(layerType == "ETLT_VECTOR_PIPE") { 
                            type = Module.TILE_LAYER_TYPE_VECTOR_PIPE;                            
                            alt = 500;
                        }
                        if(layerType == "ETLT_REAL3D") {
                            type = Module.TILE_LAYER_TYPE_REAL3D;                                                        
                        }
                        if(layerType == "ETLT_3DPOINT"){
                            type = Module.TILE_LAYER_TYPE_POI;
                            // 아래 좌표는 테스트용입니다. 제주도 
                            cenLon = 126.852;
                            cenLat = 33.523;                            
                            alt = 500;
                        }
                        Module.XDEMapCreateLayer(layerName, layerPath, 0, true, true, true, type, minLv, maxLv);                            
                        Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, alt), 89.9, 0, 0);                            
                        layer = layerList.nameAtLayer(layerName);                        

                        if (layer != null) {

                            const layerItem = document.createElement('div');
                            layerItem.className = 'layer-item';

                            // 체크박스
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', () => {
                                layer.setVisible(checkbox.checked);
                            });

                            // 레이어 이름
                            const label = document.createElement('span');
                            label.textContent = layerName;
                            label.title = layerName; // 마우스 오버 시 전체 이름 표시
                            label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                            label.addEventListener('click', () => {
                                // 레이어 클릭시 동작
                                Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, 5000), 89.9, 0, 0);
                            });

                            // x 제거 버튼
                            const removeBtn = document.createElement('button');
                            removeBtn.textContent = 'X';
                            removeBtn.addEventListener('click', () => {
                                Module.XDEMapRemoveLayer(label.textContent);
                                layerItem.remove();
                                mouseOverInterface(false);
                                if (layerType == "ETLT_VECTOR_PIPE") {
                                    Module.XDESetPlanetTransparecny(0.0);
                                }
                            });

                            // 조립
                            layerItem.appendChild(checkbox);
                            layerItem.appendChild(label);
                            
                            if (layerType == "ETLT_VECTOR_PIPE") {
                                const transparencyBtn = document.createElement('button');
                                transparencyBtn.textContent = 'T';
                                let isTransparent = false;
                                transparencyBtn.addEventListener('click', () => {
                                    isTransparent = !isTransparent;
                                    Module.XDESetPlanetTransparecny(isTransparent ? 0.25 : 1.0);
                                });
                                layerItem.appendChild(transparencyBtn);
                            }

                            layerItem.appendChild(removeBtn);

                            // 드래그 앤 드롭 가능하게 설정
                            makeDraggable(layerItem, layer, layerList);

                            document.getElementById('interface').appendChild(layerItem);
                            index++;
                        }
                    } catch (e) {
                        console.error("Failed to parse .meta file as JSON:", e);
                        alert(".meta 파일을 JSON으로 파싱하는데 실패했습니다.");
                    }
                })
                .catch(err => {
                    console.error("Failed to read .meta file:", err);
                    alert(".meta 파일을 읽는데 실패했습니다.");
                });
        }



    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</body>

</html>