<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDViewer</title>
    <link rel="stylesheet" href="style.css"> <!-- ì™¸ë¶€ CSS íŒŒì¼ ì—°ê²° -->
</head>

<body>
    <!-- ë¡œë”© í™”ë©´ -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-logo">
                <h1>XDViewer</h1>
                <p>3D ì§€ë„ ì—”ì§„ ë¡œë”©ì¤‘...</p>
            </div>
            <div class="loading-spinner">
                <div class="spinner"></div>
            </div>
            <div class="loading-text">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”</div>
        </div>
    </div>

    <!-- ì§€ë„ í‘œì‹œ ì˜ì—­ -->
    <div id='map'></div>

    <!-- VSCode ìŠ¤íƒ€ì¼ ì‚¬ì´ë“œë°” -->
    <div id="sidebar">
        <!-- íƒ­ ë°” -->
        <div id="tabbar" class="transparent">
            <button class="tab-button" data-tab="layers" title="ë ˆì´ì–´">
                â˜°
            </button>
            <button class="tab-button" data-tab="settings" title="ì„¤ì •">
                âš™
            </button>
            <button class="tab-button" data-tab="info" title="ì •ë³´">
                â“˜
            </button>
            <div style="flex:1"></div>
            <button class="tab-button" id="dbTabButton" title="ë°ì´í„°ë² ì´ìŠ¤">
                âŠ
            </button>
        </div>

        <!-- ì‚¬ì´ë“œë°” íŒ¨ë„ -->
        <div id="sidebar-panel" class="collapsed" onmouseout="mouseOverInterface(false);"
            onmouseover="mouseOverInterface(true);">
            <!-- ë ˆì´ì–´ íŒ¨ë„ -->
            <div id="layers-panel" class="panel active">
                <div class="panel-header">
                    <span>ë ˆì´ì–´</span>
                    <button id="openLayer">+</button>
                </div>
                <div class="panel-content">
                    <!-- ë ˆì´ì–´ ì•„ì´í…œë“¤ì´ ì¶”ê°€ë  ì˜ì—­ -->
                    <div id="interface"></div>
                </div>
            </div>

            <!-- ì„¤ì • íŒ¨ë„ -->
            <div id="settings-panel" class="panel">
                <div class="panel-header">
                    <span>ì„¤ì •</span>
                </div>
                <div class="panel-content settings-content">
                    <div class="settings-section">
                        <div class="settings-label">ë°°ê²½ì§€ë„</div>
                        <select id="basemapSelect" class="settings-select">
                            <option value="0">ê¸°ë³¸ (VWorld)</option>
                            <option value="1">Google (ì¼ë°˜)</option>
                            <option value="2">Google (ì§€í˜•)</option>
                            <option value="3">Google (ë²¡í„° í•˜ì´ë¸Œë¦¬ë“œ)</option>
                            <option value="4">Google (ìœ„ì„± í•˜ì´ë¸Œë¦¬ë“œ)</option>
                            <option value="5">Google (ìœ„ì„±)</option>
                            <option value="6">ArcMap (ì¼ë°˜)</option>
                            <option value="7">ArcMap (ì§€í˜•)</option>
                            <option value="8">ArcMap (ë²¡í„° í•˜ì´ë¸Œë¦¬ë“œ)</option>
                            <option value="9">ArcMap (ìœ„ì„±)</option>
                            <option value="10">OpenStreetMap</option>
                            <option value="11">ì´ˆê¸°í™”</option>
                        </select>
                    </div>
                    <div class="settings-section">
                        <div class="settings-label">ì´ë¯¸ì§€ í’ˆì§ˆ</div>
                        <select id="basemapQuality" class="settings-select">
                            <option value="low">ë‚®ìŒ</option>
                            <option value="middle" selected>ë³´í†µ</option>
                            <option value="high">ë†’ìŒ</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- ì •ë³´ íŒ¨ë„ -->
            <div id="info-panel" class="panel">
                <div class="panel-header">
                    <span>ì •ë³´</span>
                </div>
                <div class="panel-content info-content">
                    <div class="info-section">
                        <div class="info-logo">XDViewer</div>
                        <div class="info-version" id="app-version">v0.0.0</div>
                        <div class="info-description">Digital Twin Viewer</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Developer</div>
                        <div class="info-value">EGIS Co., Ltd.</div>
                    </div>
                    <div class="info-section">
                        <a href="#" id="github-link" class="info-link" title="GitHub ì €ì¥ì†Œ ì—´ê¸°">
                            <span class="github-icon">â¬¡</span>
                            <span>GitHub</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="geojsonLayerList" class="layerlist" style="margin-bottom: 10px;"></div>

    <!-- ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ (ë™ì ìœ¼ë¡œ ìƒì„±) -->
    <div id="contextMenu" class="context-menu" style="display: none;">
    </div>

    <!-- CSV ì»¬ëŸ¼ ì„ íƒ ëª¨ë‹¬ -->
    <div id="csvModal" class="csv-modal-overlay" style="display: none;">
        <div class="csv-modal">
            <div class="csv-modal-header">
                <span>CSV ì»¬ëŸ¼ ì„¤ì •</span>
                <button id="csvModalClose" class="close-properties-btn">Ã—</button>
            </div>
            <div class="csv-modal-body">
                <div class="csv-modal-info" id="csvModalInfo"></div>
                <div class="csv-modal-row">
                    <label>ê²½ë„ (Longitude)</label>
                    <select id="csvColLon"></select>
                </div>
                <div class="csv-modal-row">
                    <label>ìœ„ë„ (Latitude)</label>
                    <select id="csvColLat"></select>
                </div>
                <div class="csv-modal-row">
                    <label>ì´ë¦„ (ì„ íƒ)</label>
                    <select id="csvColName"></select>
                </div>
                <div class="csv-modal-preview">
                    <span class="csv-preview-title">ë¯¸ë¦¬ë³´ê¸° (ìƒìœ„ 5ê±´)</span>
                    <table id="csvPreviewTable"></table>
                </div>
            </div>
            <div class="csv-modal-footer">
                <button id="csvModalCancel" class="csv-btn csv-btn-cancel">ì·¨ì†Œ</button>
                <button id="csvModalOk" class="csv-btn csv-btn-ok">í™•ì¸</button>
            </div>
        </div>
    </div>

    <!-- í•˜ë‹¨ íŒ¨ë„ ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ -->
    <div id="bottom-panel-resizer"></div>

    <!-- í•˜ë‹¨ íŒ¨ë„ (SQL ë°ì´í„° ë·°ì–´) -->
    <div id="bottom-panel" onmouseover="mouseOverInterface(true);" onmouseout="mouseOverInterface(false);">
        <div id="bottom-panel-header">
            <div id="bottom-panel-tabs">
                <span class="bottom-panel-title">SQL</span>
                <select id="sqlTableSelect" title="í…Œì´ë¸” ì„ íƒ">
                    <option value="">í…Œì´ë¸” ì„ íƒ...</option>
                </select>
            </div>
            <div id="bottom-panel-actions">
                <span id="sqlStatus"></span>
                <button id="bottomPanelClose" title="ë‹«ê¸°">&times;</button>
            </div>
        </div>
        <div id="bottom-panel-content">
            <div id="sql-query-area">
                <textarea id="sqlInput" placeholder="SELECT * FROM tablename LIMIT 100" spellcheck="false"></textarea>
                <button id="sqlRunBtn" class="csv-btn csv-btn-ok" title="Ctrl+Enter">ì‹¤í–‰</button>
            </div>
            <div id="sql-results-area">
                <table id="sqlResultsTable">
                    <thead id="sqlResultsHead"></thead>
                    <tbody id="sqlResultsBody"></tbody>
                </table>
            </div>
            <div id="sqlResultsInfo"></div>
        </div>
    </div>

    <script>
        index = 0;

        // ============ SQLite ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ============
        let sqlDb = null;
        let sqlReady = false;
        const sqlTableMap = {};

        async function initSqlite() {
            try {
                const SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/${file}`
                });
                sqlDb = new SQL.Database();
                sqlReady = true;
                console.log('SQLite ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (err) {
                console.error('SQLite ì´ˆê¸°í™” ì‹¤íŒ¨:', err);
            }
        }

        function sanitizeTableName(name) {
            let safe = name.replace(/[^a-zA-Z0-9ê°€-í£_]/g, '_').replace(/^[0-9]/, '_$&');
            // í…Œì´ë¸”ëª… ì¤‘ë³µ ì‹œ ì ‘ë¯¸ì‚¬ ì¶”ê°€
            if (sqlTableMap[safe]) {
                let i = 2;
                while (sqlTableMap[safe + '_' + i]) i++;
                safe = safe + '_' + i;
            }
            return safe || 'table_' + Date.now();
        }

        function importCsvToSqlite(tableName, headers, rows) {
            if (!sqlDb || !sqlReady) return null;

            const safeName = sanitizeTableName(tableName);
            const safeHeaders = headers.map((h, i) => {
                const safe = h.replace(/[^a-zA-Z0-9ê°€-í£_]/g, '_').replace(/^[0-9]/, '_$&');
                return safe || 'col_' + i;
            });

            // ì»¬ëŸ¼ íƒ€ì… ì¶”ë¡ 
            const types = safeHeaders.map((_, colIdx) => {
                let numCount = 0;
                const sampleSize = Math.min(20, rows.length);
                for (let i = 0; i < sampleSize; i++) {
                    const val = rows[i] && rows[i][colIdx];
                    if (val !== undefined && val !== '' && !isNaN(Number(val))) numCount++;
                }
                return (sampleSize > 0 && numCount / sampleSize >= 0.8) ? 'REAL' : 'TEXT';
            });

            const colDefs = safeHeaders.map((h, i) => `"${h}" ${types[i]}`).join(', ');
            sqlDb.run(`DROP TABLE IF EXISTS "${safeName}"`);
            sqlDb.run(`CREATE TABLE "${safeName}" (${colDefs})`);

            const placeholders = safeHeaders.map(() => '?').join(', ');
            const insertSql = `INSERT INTO "${safeName}" VALUES (${placeholders})`;

            sqlDb.run('BEGIN TRANSACTION');
            for (const row of rows) {
                const values = safeHeaders.map((_, i) => {
                    const val = row[i];
                    if (val === undefined || val === '') return null;
                    if (types[i] === 'REAL' && !isNaN(Number(val))) return Number(val);
                    return val;
                });
                sqlDb.run(insertSql, values);
            }
            sqlDb.run('COMMIT');

            sqlTableMap[safeName] = { originalName: tableName, rowCount: rows.length };
            updateTableSelect();
            console.log(`SQLite í…Œì´ë¸” "${safeName}" ìƒì„±: ${rows.length}í–‰`);
            return safeName;
        }

        function importGeoJsonToSqlite(tableName, features) {
            if (!sqlDb || !sqlReady || !features || features.length === 0) return null;

            const safeName = sanitizeTableName(tableName);

            // ëª¨ë“  featureì˜ properties í‚¤ ìˆ˜ì§‘
            const propKeys = new Set();
            for (const f of features) {
                if (f.properties) Object.keys(f.properties).forEach(k => propKeys.add(k));
            }
            const propArray = Array.from(propKeys);

            // íŠ¹ìˆ˜ ì»¬ëŸ¼ + properties ì»¬ëŸ¼
            const allCols = ['_id', '_geometry_type', '_longitude', '_latitude', ...propArray];
            const safeCols = allCols.map(h => h.replace(/[^a-zA-Z0-9ê°€-í£_]/g, '_').replace(/^[0-9]/, '_$&'));

            // íƒ€ì… ì¶”ë¡ 
            const types = allCols.map((col, idx) => {
                if (idx <= 1) return 'TEXT'; // _id, _geometry_type
                if (idx <= 3) return 'REAL'; // _longitude, _latitude
                let numCount = 0;
                const sampleSize = Math.min(20, features.length);
                for (let i = 0; i < sampleSize; i++) {
                    const val = features[i].properties && features[i].properties[propArray[idx - 4]];
                    if (val !== undefined && val !== null && val !== '' && !isNaN(Number(val))) numCount++;
                }
                return (sampleSize > 0 && numCount / sampleSize >= 0.8) ? 'REAL' : 'TEXT';
            });

            const colDefs = safeCols.map((h, i) => `"${h}" ${types[i]}`).join(', ');
            sqlDb.run(`DROP TABLE IF EXISTS "${safeName}"`);
            sqlDb.run(`CREATE TABLE "${safeName}" (${colDefs})`);

            const placeholders = safeCols.map(() => '?').join(', ');
            const insertSql = `INSERT INTO "${safeName}" VALUES (${placeholders})`;

            sqlDb.run('BEGIN TRANSACTION');
            for (const f of features) {
                const geom = f.geometry;
                let lon = null, lat = null;
                if (geom && geom.coordinates) {
                    if (geom.type === 'Point') {
                        lon = geom.coordinates[0]; lat = geom.coordinates[1];
                    } else if (geom.type === 'LineString' || geom.type === 'MultiLineString') {
                        const coords = geom.type === 'LineString' ? geom.coordinates : geom.coordinates[0];
                        if (coords && coords.length > 0) { lon = coords[0][0]; lat = coords[0][1]; }
                    } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
                        const ring = geom.type === 'Polygon' ? geom.coordinates[0] : geom.coordinates[0][0];
                        if (ring && ring.length > 0) { lon = ring[0][0]; lat = ring[0][1]; }
                    }
                }

                const values = [
                    f.id || f.properties?.id || null,
                    geom ? geom.type : null,
                    lon, lat,
                    ...propArray.map(k => {
                        const val = f.properties && f.properties[k];
                        if (val === undefined || val === null) return null;
                        return val;
                    })
                ];
                sqlDb.run(insertSql, values);
            }
            sqlDb.run('COMMIT');

            sqlTableMap[safeName] = { originalName: tableName, rowCount: features.length };
            updateTableSelect();
            console.log(`SQLite í…Œì´ë¸” "${safeName}" ìƒì„±: ${features.length}í–‰`);
            return safeName;
        }

        function executeSqlQuery(sql) {
            if (!sqlDb || !sqlReady) return { error: 'SQLiteê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' };
            try {
                const results = sqlDb.exec(sql);
                if (results.length === 0) return { columns: [], values: [], message: 'ê²°ê³¼ ì—†ìŒ (0í–‰)' };
                return { columns: results[0].columns, values: results[0].values, message: `${results[0].values.length}í–‰ ë°˜í™˜` };
            } catch (err) {
                return { error: err.message };
            }
        }

        function findSqliteTable(name) {
            const safeName = name.replace(/[^a-zA-Z0-9ê°€-í£_]/g, '_').replace(/^[0-9]/, '_$&');
            for (const key of Object.keys(sqlTableMap)) {
                if (key === safeName || sqlTableMap[key].originalName === name) return key;
            }
            return null;
        }

        function dropSqliteTable(tableName) {
            if (!sqlDb || !sqlReady) return;
            const key = findSqliteTable(tableName);
            if (key) {
                // í˜„ì¬ í‘œì‹œ ì¤‘ì¸ í…Œì´ë¸”ì´ë©´ ê²°ê³¼ ì´ˆê¸°í™”
                const select = document.getElementById('sqlTableSelect');
                if (select && select.value === key) {
                    select.value = '';
                    document.getElementById('sqlInput').value = '';
                    document.getElementById('sqlResultsHead').innerHTML = '';
                    document.getElementById('sqlResultsBody').innerHTML = '';
                    document.getElementById('sqlResultsInfo').textContent = '';
                    document.getElementById('sqlStatus').textContent = '';
                    document.getElementById('sqlStatus').className = '';
                }

                sqlDb.run(`DROP TABLE IF EXISTS "${key}"`);
                delete sqlTableMap[key];
                updateTableSelect();

                // í…Œì´ë¸”ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ íŒ¨ë„ ë‹«ê¸°
                if (Object.keys(sqlTableMap).length === 0) {
                    hideBottomPanel();
                }
            }
        }

        // ============ í•˜ë‹¨ íŒ¨ë„ (SQL ë°ì´í„° ë·°ì–´) ============
        let bottomPanelVisible = false;
        let bottomPanelHeight = 250;

        function showBottomPanel() {
            document.getElementById('bottom-panel').classList.add('visible');
            document.getElementById('bottom-panel-resizer').classList.add('visible');
            bottomPanelVisible = true;
            updateMapSize();
        }

        function hideBottomPanel() {
            document.getElementById('bottom-panel').classList.remove('visible');
            document.getElementById('bottom-panel-resizer').classList.remove('visible');
            bottomPanelVisible = false;
            updateMapSize();
        }

        function updateMapSize() {
            const mapEl = document.getElementById('map');
            if (bottomPanelVisible) {
                mapEl.style.height = `calc(100% - ${bottomPanelHeight}px)`;
                document.getElementById('bottom-panel').style.height = bottomPanelHeight + 'px';
                document.getElementById('bottom-panel-resizer').style.bottom = bottomPanelHeight + 'px';
            } else {
                mapEl.style.height = '100%';
            }
            if (typeof Module === 'object' && typeof Module.Resize === 'function') {
                const h = bottomPanelVisible ? window.innerHeight - bottomPanelHeight : window.innerHeight;
                Module.Resize(window.innerWidth, h);
                Module.XDRenderData();
            }
            // ì„ íƒ íŒ¨ë„ ìœ„ì¹˜ ì¡°ì •
            const selPanel = document.getElementById('selection-panel');
            if (selPanel) {
                selPanel.style.bottom = bottomPanelVisible ? (bottomPanelHeight + 20) + 'px' : '20px';
            }
        }

        function updateTableSelect() {
            const select = document.getElementById('sqlTableSelect');
            if (!select) return;
            select.innerHTML = '<option value="">í…Œì´ë¸” ì„ íƒ...</option>';
            for (const name of Object.keys(sqlTableMap)) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = `${sqlTableMap[name].originalName} (${sqlTableMap[name].rowCount}í–‰)`;
                select.appendChild(opt);
            }
        }

        function runDefaultQuery(tableName) {
            const sql = `SELECT * FROM "${tableName}" LIMIT 100`;
            document.getElementById('sqlInput').value = sql;
            executeAndDisplayQuery(sql);
        }

        function executeAndDisplayQuery(sql) {
            const status = document.getElementById('sqlStatus');
            const thead = document.getElementById('sqlResultsHead');
            const tbody = document.getElementById('sqlResultsBody');
            const info = document.getElementById('sqlResultsInfo');

            const t0 = performance.now();
            const result = executeSqlQuery(sql);
            const elapsed = (performance.now() - t0).toFixed(1);

            if (result.error) {
                status.textContent = result.error;
                status.className = 'error';
                thead.innerHTML = '';
                tbody.innerHTML = '';
                info.textContent = '';
                return;
            }

            status.textContent = `${result.message} (${elapsed}ms)`;
            status.className = 'success';

            let headHtml = '<tr><th>#</th>';
            result.columns.forEach(col => { headHtml += `<th>${col}</th>`; });
            headHtml += '</tr>';
            thead.innerHTML = headHtml;

            let bodyHtml = '';
            result.values.forEach((row, i) => {
                bodyHtml += `<tr data-row-idx="${i}">`;
                bodyHtml += `<td style="color:#858585">${i + 1}</td>`;
                row.forEach(val => {
                    const display = val !== null ? String(val) : '';
                    const cls = val === null ? ' style="color:#555"' : '';
                    bodyHtml += `<td title="${display}"${cls}>${val !== null ? display : 'NULL'}</td>`;
                });
                bodyHtml += '</tr>';
            });
            tbody.innerHTML = bodyHtml;
            info.textContent = `${result.values.length}í–‰ | ${result.columns.length}ê°œ ì»¬ëŸ¼`;

            // í–‰ í´ë¦­: ì¢Œí‘œ ì»¬ëŸ¼ ê°ì§€í•˜ì—¬ ì¹´ë©”ë¼ ì´ë™
            const lonKw = ['ê²½ë„', 'lon', 'longitude', 'lng', '_longitude'];
            const latKw = ['ìœ„ë„', 'lat', 'latitude', '_latitude'];
            let lonCol = -1, latCol = -1;
            result.columns.forEach((col, i) => {
                const lc = col.toLowerCase();
                if (lonCol < 0 && lonKw.some(k => lc.includes(k))) lonCol = i;
                if (latCol < 0 && latKw.some(k => lc.includes(k))) latCol = i;
            });

            tbody.querySelectorAll('tr').forEach(tr => {
                tr.addEventListener('click', () => {
                    tbody.querySelectorAll('tr.selected').forEach(r => r.classList.remove('selected'));
                    tr.classList.add('selected');
                    if (lonCol >= 0 && latCol >= 0) {
                        const idx = parseInt(tr.dataset.rowIdx);
                        const lon = parseFloat(result.values[idx][lonCol]);
                        const lat = parseFloat(result.values[idx][latCol]);
                        if (!isNaN(lon) && !isNaN(lat) && typeof Module !== 'undefined') {
                            const camera = Module.getViewCamera();
                            if (camera) camera.move(new Module.JSVector3D(lon, lat, 500), 89.9, 0, 0);
                        }
                    }
                });
            });
        }

        // í•˜ë‹¨ íŒ¨ë„ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
        function initBottomPanel() {
            // ë¦¬ì‚¬ì´ì €
            const resizer = document.getElementById('bottom-panel-resizer');
            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                resizer.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newH = window.innerHeight - e.clientY;
                bottomPanelHeight = Math.max(100, Math.min(newH, window.innerHeight * 0.7));
                updateMapSize();
            });
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizer.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });

            // ë‹«ê¸°
            document.getElementById('bottomPanelClose').addEventListener('click', hideBottomPanel);

            // DB íƒ­ ë²„íŠ¼ í† ê¸€
            document.getElementById('dbTabButton').addEventListener('click', () => {
                bottomPanelVisible ? hideBottomPanel() : showBottomPanel();
            });

            // ì‹¤í–‰ ë²„íŠ¼
            document.getElementById('sqlRunBtn').addEventListener('click', () => {
                const sql = document.getElementById('sqlInput').value.trim();
                if (sql) executeAndDisplayQuery(sql);
            });

            // Ctrl+Enter ì‹¤í–‰
            document.getElementById('sqlInput').addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    const sql = e.target.value.trim();
                    if (sql) executeAndDisplayQuery(sql);
                }
            });

            // í…Œì´ë¸” ì„ íƒ
            document.getElementById('sqlTableSelect').addEventListener('change', (e) => {
                if (e.target.value) runDefaultQuery(e.target.value);
            });
        }

        // POI ì•„ì´ì½˜ SVG í…œí”Œë¦¿ (COLOR_PLACEHOLDERë¥¼ ì‹¤ì œ ìƒ‰ìƒìœ¼ë¡œ êµì²´)
        const POI_ICON_TEMPLATES = {
            'pin': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36" width="24" height="36"><path fill="COLOR_PLACEHOLDER" d="M12,2C7.6,2,4,5.6,4,10c0,6.4,8,16,8,16s8-9.6,8-16C20,5.6,16.4,2,12,2z"/><circle fill="#FFF" cx="12" cy="10" r="4"/></svg>',
            'star': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="COLOR_PLACEHOLDER" d="M12,2.5l3.1,6.3l6.9,1l-5,4.9l1.2,6.9L12,18l-6.2,3.3l1.2-6.9l-5-4.9l6.9-1L12,2.5z"/></svg>',
            'home': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="COLOR_PLACEHOLDER" d="M10,20v-6h4v6h5V12h3L12,3l-10,9h3V20h5z"/></svg>',
            'flag': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="COLOR_PLACEHOLDER" d="M14,6l-1,2H7V4H6V21H7V13h5l-1,2h6V6h-3z"/></svg>',
            'circle': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><circle fill="COLOR_PLACEHOLDER" cx="12" cy="12" r="8"/></svg>'
        };

        // SVG í…œí”Œë¦¿ì— ìƒ‰ìƒì„ ì ìš©í•˜ì—¬ data URL ìƒì„±
        function createColoredIconUrl(templateName, hexColor) {
            if (!POI_ICON_TEMPLATES[templateName]) {
                // í…œí”Œë¦¿ì´ ì—†ìœ¼ë©´ circleì„ ê¸°ë³¸ê°’ìœ¼ë¡œ
                templateName = 'circle';
            }
            const svg = POI_ICON_TEMPLATES[templateName].replace('COLOR_PLACEHOLDER', hexColor);
            const base64 = btoa(svg);
            return 'data:image/svg+xml;base64,' + base64;
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸° í•¨ìˆ˜ (ì „ì—­)
        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu) {
                contextMenu.style.display = 'none';
            }
            // ë ˆì´ì–´ ê°•ì¡° ì œê±°
            document.querySelectorAll('.layer-item.context-menu-active, .layer-item-container.context-menu-active').forEach(item => {
                item.classList.remove('context-menu-active');
            });
            window.currentContextLayer = null;
        }

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í‘œì‹œ í•¨ìˆ˜ (ìœ„ì¹˜ ìë™ ì¡°ì •)
        function showContextMenu(event, targetElement) {
            const contextMenu = document.getElementById('contextMenu');

            // ê¸°ì¡´ ê°•ì¡° ì œê±°
            document.querySelectorAll('.layer-item.context-menu-active, .layer-item-container.context-menu-active').forEach(item => {
                item.classList.remove('context-menu-active');
            });

            // í˜„ì¬ ìš”ì†Œ ê°•ì¡°
            if (targetElement) {
                targetElement.classList.add('context-menu-active');
            }

            // ë©”ë‰´ë¥¼ ì¼ë‹¨ í‘œì‹œ (í¬ê¸° ê³„ì‚°ì„ ìœ„í•´)
            contextMenu.style.display = 'block';
            contextMenu.style.transform = 'none';

            // ë§ˆìš°ìŠ¤ ìœ„ì¹˜
            let x = event.clientX;
            let y = event.clientY;

            // ë©”ë‰´ í¬ê¸°
            const menuRect = contextMenu.getBoundingClientRect();
            const menuWidth = menuRect.width;
            const menuHeight = menuRect.height;

            // í™”ë©´ í¬ê¸°
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë²—ì–´ë‚˜ëŠ” ê²½ìš° ì™¼ìª½ìœ¼ë¡œ ì´ë™
            if (x + menuWidth > viewportWidth) {
                x = viewportWidth - menuWidth - 10;
            }

            // ì•„ë˜ë¡œ ë²—ì–´ë‚˜ëŠ” ê²½ìš° ìœ„ë¡œ ì´ë™
            if (y + menuHeight > viewportHeight) {
                y = viewportHeight - menuHeight - 10;
            }

            // ìœ„ë¡œ ë²—ì–´ë‚˜ëŠ” ê²½ìš°
            if (y < 0) {
                y = 10;
            }

            // ì™¼ìª½ìœ¼ë¡œ ë²—ì–´ë‚˜ëŠ” ê²½ìš°
            if (x < 0) {
                x = 10;
            }

            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
        }

        function getLayerSemanticType(layer) {
            const t = layer.getType();

            switch (t) {
                case 5: // ELT_3DPOINT
                case 3: // ELT_BILLBOARD
                case 6: // ELT_3DS_SYMBOL
                    return "point";

                case 4: // ELT_3DLINE
                case 2: // ELT_PIPE
                    return "line";

                case 0: // ELT_POLYHEDRON
                case 1: // ELT_PLANE
                    return "polygon";

                case 8:  // ELT_TERRAIN
                case 11: // ELT_TERRAIN_IMAGE
                    return "raster";

                case 9:  // REAL3D / MULTIPLE (SDKë³„ ë‹¤ë¦„)
                case 20: // TILE_LOD_MODEL
                    return "3dmodel";

                case 19: // POINT_CLOUD
                    return "pointcloud";

                default:
                    return "unknown";
            }
        }

        function buildContextMenu(layerData) {
            const menu = document.getElementById('contextMenu');
            menu.innerHTML = '';
            //menu.onclick = e => e.stopPropagation();

            // ê³µí†µ ë©”ë‰´ ì•„ì´í…œ ì¶”ê°€ í—¬í¼
            const addMenuItem = (text, handler, danger = false) => {
                const item = document.createElement('div');
                item.className = 'context-menu-item' + (danger ? ' danger' : '');
                item.textContent = text;
                item.onclick = handler;
                menu.appendChild(item);
            };

            // =========================
            // 1) ë ˆì´ì–´ë¡œ ì´ë™
            // =========================
            addMenuItem('ë ˆì´ì–´ë¡œ ì´ë™', () => {
                layerData.label?.click();
                hideContextMenu();
            });

            // =========================
            // 2) ë ˆì´ì–´ ì´ë¦„ ë³€ê²½ (Label â†” Input í† ê¸€)
            // =========================
            const nameBox = document.createElement('div');
            nameBox.className = 'context-menu-item';
            nameBox.style.display = 'flex';
            nameBox.style.alignItems = 'center';
            nameBox.style.gap = '5px';

            // label (ê¸°ë³¸ í‘œì‹œ)
            const nameLabel = document.createElement('span');
            nameLabel.textContent = layerData.label?.textContent || 'Layer';
            nameLabel.style.width = '200px';
            nameLabel.style.display = 'inline-block';

            // input (ìˆ¨ê¹€)
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.style.width = '200px';
            nameInput.style.padding = '4px 8px';
            nameInput.style.border = '1px solid #007acc';
            nameInput.style.borderRadius = '3px';
            nameInput.style.background = '#3c3c3c';
            nameInput.style.color = '#fff';
            nameInput.style.outline = 'none';
            nameInput.style.display = 'none';

            // í´ë¦­ ì‹œ ê°•ì œ í¬ì»¤ìŠ¤
            nameInput.addEventListener('mousedown', async (e) => {
                e.stopPropagation();
                if (window.electronAPI?.focusWindow) {
                    await window.electronAPI.focusWindow();
                }
            });
            nameInput.addEventListener('click', (e) => {
                e.stopPropagation();
                nameInput.focus();
            });

            // ë²„íŠ¼
            const nameBtn = document.createElement('button');
            nameBtn.textContent = 'ë³€ê²½';
            nameBtn.style.width = '50px';

            let editing = false;

            nameBtn.onclick = async () => {
                editing = !editing;

                if (editing) {
                    // ë³€ê²½ ëª¨ë“œ ì§„ì…
                    nameInput.value = nameLabel.textContent;
                    nameLabel.style.display = 'none';
                    nameInput.style.display = 'inline-block';
                    nameBtn.textContent = 'ì ìš©';

                    // í¬ì»¤ìŠ¤ (ë°˜ë³µ ì‹œë„)
                    if (window.electronAPI?.focusWindow) {
                        await window.electronAPI.focusWindow();
                    }
                    const focusInterval = setInterval(() => {
                        if (window.electronAPI?.focusWindow) {
                            window.electronAPI.focusWindow();
                        }
                        nameInput.focus();
                        if (document.activeElement === nameInput) {
                            nameInput.select();
                            clearInterval(focusInterval);
                        }
                    }, 100);
                    setTimeout(() => clearInterval(focusInterval), 2000);
                } else {
                    // ì ìš©
                    const newName = nameInput.value.trim() || 'Layer';
                    nameLabel.textContent = newName;
                    layerData.name = newName;
                    if (layerData.label) layerData.label.textContent = newName;

                    nameLabel.style.display = 'inline-block';
                    nameInput.style.display = 'none';
                    nameBtn.textContent = 'ë³€ê²½';
                }
            };

            nameInput.onkeydown = (e) => {
                if (e.key === 'Enter') nameBtn.click();
                if (e.key === 'Escape') {
                    editing = false;
                    nameLabel.style.display = 'inline-block';
                    nameInput.style.display = 'none';
                    nameBtn.textContent = 'ë³€ê²½';
                }
            };

            nameBox.appendChild(nameLabel);
            nameBox.appendChild(nameInput);
            nameBox.appendChild(nameBtn);
            menu.appendChild(nameBox);


            // =========================
            // 3) semantic type íŒë³„
            // =========================
            const semanticType = getLayerSemanticType(layerData.layer);

            // =========================
            // 4) íƒ€ì…ë³„ ìŠ¤íƒ€ì¼ UI
            // =========================
            const styleBox = document.createElement('div');
            styleBox.className = 'context-menu-item';

            const colorPicker = (label, key) => {
                const wrap = document.createElement('div');
                wrap.style.display = 'flex';
                wrap.style.justifyContent = 'space-between';
                wrap.style.alignItems = 'center';

                const span = document.createElement('span');
                span.textContent = label;

                const controlWrap = document.createElement('div');
                controlWrap.style.display = 'flex';
                controlWrap.style.alignItems = 'center';
                controlWrap.style.gap = '8px';

                const input = document.createElement('input');
                input.type = 'color';
                input.value = layerData.style?.[key] || '#ffffff';

                const hexCode = document.createElement('span');
                hexCode.className = 'color-code';
                hexCode.textContent = input.value.toUpperCase();

                input.oninput = () => {
                    layerData.style = layerData.style || {};
                    layerData.style[key] = input.value;
                    hexCode.textContent = input.value.toUpperCase();
                    layerData.updateStyle?.();
                };

                controlWrap.append(input, hexCode);
                wrap.append(span, controlWrap);
                return wrap;
            };

            const rangeSlider = (label, min, max, key) => {
                const wrap = document.createElement('div');
                wrap.style.display = 'flex';
                wrap.style.justifyContent = 'space-between';
                wrap.style.alignItems = 'center';

                const span = document.createElement('span');
                span.textContent = label;

                const controlWrap = document.createElement('div');
                controlWrap.style.display = 'flex';
                controlWrap.style.alignItems = 'center';
                controlWrap.style.gap = '8px';

                const input = document.createElement('input');
                input.type = 'range';
                input.min = min;
                input.max = max;
                input.value = layerData.style?.[key] || min;
                input.style.width = '100px';

                const valueSpan = document.createElement('span');
                valueSpan.textContent = input.value;
                valueSpan.style.fontSize = '11px';
                valueSpan.style.color = '#cccccc';
                valueSpan.style.minWidth = '25px';
                valueSpan.style.textAlign = 'right';

                input.oninput = () => {
                    layerData.style = layerData.style || {};
                    layerData.style[key] = input.value;
                    valueSpan.textContent = input.value;
                    layerData.updateStyle?.();
                };

                controlWrap.append(input, valueSpan);
                wrap.append(span, controlWrap);
                return wrap;
            };

            const iconSelector = (label, key) => {
                const wrap = document.createElement('div');
                wrap.style.display = 'flex';
                wrap.style.justifyContent = 'space-between';
                wrap.style.alignItems = 'center';

                const span = document.createElement('span');
                span.textContent = label;

                const select = document.createElement('select');
                select.style.backgroundColor = '#3c3c3c';
                select.style.color = '#cccccc';
                select.style.border = '1px solid #555';
                select.style.borderRadius = '3px';
                select.style.padding = '4px 8px';
                select.style.fontSize = '11px';
                select.style.cursor = 'pointer';
                select.style.outline = 'none';
                select.style.minWidth = '120px';

                const options = [
                    { value: 'circle', text: 'â— ì›í˜•' },
                    { value: 'pin', text: 'ğŸ“ í•€' },
                    { value: 'star', text: 'â­ ë³„' },
                    { value: 'home', text: 'ğŸ  ì§‘' },
                    { value: 'flag', text: 'ğŸš© ê¹ƒë°œ' }
                ];

                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.text;
                    select.appendChild(option);
                });

                select.value = layerData.style?.[key] || 'circle';

                select.onchange = () => {
                    layerData.style = layerData.style || {};
                    layerData.style[key] = select.value;
                    console.log('ì•„ì´ì½˜ íƒ€ì… ë³€ê²½:', select.value);
                    layerData.updateStyle?.();
                };

                wrap.append(span, select);
                return wrap;
            };

            // íƒ€ì…ë³„ UI ë¶„ê¸°
            if (semanticType === "point") {
                styleBox.appendChild(colorPicker('ì  ìƒ‰ìƒ', 'pointColor'));
                styleBox.appendChild(rangeSlider('ì  í¬ê¸°', 1, 50, 'pointSize'));
                styleBox.appendChild(iconSelector('ì•„ì´ì½˜ ì¢…ë¥˜', 'iconType'));
            }

            if (semanticType === "line") {
                styleBox.appendChild(colorPicker('ì„  ìƒ‰ìƒ', 'lineColor'));
                styleBox.appendChild(rangeSlider('ì„  ë‘ê»˜', 1, 20, 'lineWidth'));
            }

            if (semanticType === "polygon") {
                styleBox.appendChild(colorPicker('ë©´ìƒ‰ìƒ', 'fillColor'));
                styleBox.appendChild(rangeSlider('ë©´íˆ¬ëª…ë„', 0, 100, 'fillOpacity'));

                const divider = document.createElement('div');
                divider.style.height = '1px';
                divider.style.backgroundColor = '#454545';
                divider.style.margin = '8px 0';
                styleBox.appendChild(divider);

                styleBox.appendChild(colorPicker('ì„ ìƒ‰ìƒ', 'lineColor'));
                styleBox.appendChild(rangeSlider('ì„ íˆ¬ëª…ë„', 0, 100, 'strokeOpacity'));
            }

            if (styleBox.children.length > 0) {
                menu.appendChild(styleBox);
            }

            // =========================
            // 5) í…Œì´ë¸” ì—´ê¸°
            // =========================
            const layerFileName = layerData.fileName || layerData.label?.textContent;
            if (layerFileName) {
                const tableName = findSqliteTable(layerFileName);
                if (tableName) {
                    addMenuItem('í…Œì´ë¸” ì—´ê¸°', () => {
                        showBottomPanel();
                        document.getElementById('sqlTableSelect').value = tableName;
                        runDefaultQuery(tableName);
                        hideContextMenu();
                    });
                }
            }

            // =========================
            // 6) ë ˆì´ì–´ ì œê±°
            // =========================
            addMenuItem('ë ˆì´ì–´ ì œê±°', () => {
                layerData.removeBtn?.click();
                hideContextMenu();
            }, true);
  
        }


        // ì‚¬ì´ë“œë°” íƒ­ í† ê¸€ ê¸°ëŠ¥
        document.addEventListener('DOMContentLoaded', async () => {
            // ì•± ë²„ì „ í‘œì‹œ
            if (window.electronAPI?.getAppVersion) {
                const version = await window.electronAPI.getAppVersion();
                document.getElementById('app-version').textContent = `v${version}`;
                document.title = `XDViewer v${version}`;
            }

            // GitHub ë§í¬ í´ë¦­ ì´ë²¤íŠ¸
            const githubLink = document.getElementById('github-link');
            if (githubLink) {
                githubLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    window.electronAPI.openExternal('https://github.com/XDBuilder/XDViewer');
                });
            }

            // ë² ì´ìŠ¤ë§µ ë³€ê²½
            let currentBasemap = null;
            const basemapSelect = document.getElementById('basemapSelect');
            const basemapQuality = document.getElementById('basemapQuality');

            function applyBasemap(type) {
                const t = parseInt(type);
                // ê¸°ì¡´ ë² ì´ìŠ¤ë§µ ì œê±°
                if (currentBasemap) {
                    currentBasemap.clear();
                    currentBasemap = null;
                }
                if (t === 0) return;
                if (t === 11) { basemapSelect.value = '0'; return; }

                switch (t) {
                    case 1:  currentBasemap = Module.GoogleMap(); currentBasemap.layername = 'normal'; break;
                    case 2:  currentBasemap = Module.GoogleMap(); currentBasemap.layername = 'terrain'; break;
                    case 3:  currentBasemap = Module.GoogleMap(); currentBasemap.layername = 'vectorhybrid'; break;
                    case 4:  currentBasemap = Module.GoogleMap(); currentBasemap.layername = 'satellitehybrid'; break;
                    case 5:  currentBasemap = Module.GoogleMap(); currentBasemap.layername = 'satellite'; break;
                    case 6:  currentBasemap = Module.ArcMap(); currentBasemap.layername = 'normal'; break;
                    case 7:  currentBasemap = Module.ArcMap(); currentBasemap.layername = 'terrain'; break;
                    case 8:  currentBasemap = Module.ArcMap(); currentBasemap.layername = 'vectorhybrid'; break;
                    case 9:  currentBasemap = Module.ArcMap(); currentBasemap.layername = 'satellite'; break;
                    case 10: currentBasemap = Module.OpenStreetMap(); currentBasemap.layername = 'normal'; break;
                }
                if (currentBasemap) {
                    const quality = basemapQuality.value;
                    currentBasemap.quality = quality;
                    currentBasemap.zerolevelOffset = (quality === 'low') ? 0 : 1;
                    currentBasemap.refresh();
                }
            }

            basemapSelect.addEventListener('change', (e) => applyBasemap(e.target.value));
            basemapQuality.addEventListener('change', () => {
                if (currentBasemap) {
                    const quality = basemapQuality.value;
                    currentBasemap.quality = quality;
                    currentBasemap.zerolevelOffset = (quality === 'low') ? 0 : 1;
                    currentBasemap.refresh();
                }
            });

            const tabButtons = document.querySelectorAll('.tab-button');
            const sidebarPanel = document.getElementById('sidebar-panel');
            const tabbar = document.getElementById('tabbar');
            const mapElement = document.getElementById('map');
            const contextMenu = document.getElementById('contextMenu');
            let currentTab = null;
            let currentContextLayer = null;

            // WebGL canvasê°€ í¬ì»¤ìŠ¤ë¥¼ ê°€ì ¸ê°€ì§€ ì•Šë„ë¡ ì„¤ì •
            const disableCanvasFocus = () => {
                const canvases = mapElement.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    canvas.tabIndex = -1;
                });
            };
            // ì´ˆê¸° ì„¤ì • ë° MutationObserverë¡œ ë™ì  canvas ê°ì‹œ
            disableCanvasFocus();
            new MutationObserver(disableCanvasFocus).observe(mapElement, { childList: true, subtree: true });

            // ì‚¬ì´ë“œë°” ë‹«ê¸° í•¨ìˆ˜
            function closeSidebar() {
                if (!sidebarPanel.classList.contains('collapsed')) {
                    sidebarPanel.classList.add('collapsed');
                    tabbar.classList.add('transparent');
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    currentTab = null;
                }
            }

            // ì „ì—­ í´ë¦­ ì‹œ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.context-menu')) {
                    hideContextMenu();
                }
            });

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.getAttribute('data-tab');

                    // ê°™ì€ íƒ­ì„ ë‹¤ì‹œ í´ë¦­í•˜ë©´ íŒ¨ë„ ë‹«ê¸°
                    if (currentTab === tabName && !sidebarPanel.classList.contains('collapsed')) {
                        closeSidebar();
                    } else {
                        // ë‹¤ë¥¸ íƒ­ í´ë¦­ ì‹œ íŒ¨ë„ ì—´ê¸°
                        sidebarPanel.classList.remove('collapsed');
                        tabbar.classList.remove('transparent');

                        // ëª¨ë“  íƒ­ ë²„íŠ¼ê³¼ íŒ¨ë„ ë¹„í™œì„±í™”
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));

                        // ì„ íƒëœ íƒ­ í™œì„±í™”
                        button.classList.add('active');
                        document.getElementById(`${tabName}-panel`).classList.add('active');
                        currentTab = tabName;
                    }
                });
            });

            // ì§€ë„ í´ë¦­ ì‹œ í™•ì¥ ë©”ë‰´ ë˜ëŠ” ì‚¬ì´ë“œë°” ë‹«ê¸°
            mapElement.addEventListener('mousedown', (e) => {
                // ì‚¬ì´ë“œë°” ì˜ì—­ í´ë¦­ì€ ì œì™¸
                if (!e.target.closest('#sidebar')) {
                    // í™•ì¥ ë©”ë‰´ê°€ ì—´ë ¤ìˆëŠ”ì§€ í™•ì¸
                    const expandedLayer = document.querySelector('.layer-item-container.expanded');

                    if (expandedLayer) {
                        // í™•ì¥ ë©”ë‰´ê°€ ì—´ë ¤ìˆìœ¼ë©´ ë¨¼ì € ë‹«ê¸°
                        expandedLayer.classList.remove('expanded');
                        e.stopPropagation();
                        return;
                    }

                    // í™•ì¥ ë©”ë‰´ê°€ ì—†ìœ¼ë©´ ì‚¬ì´ë“œë°” ë‹«ê¸°
                    closeSidebar();
                }
            });

            // ì§€ë„ íœ (ì¤Œ) ì‚¬ìš© ì‹œ ì‚¬ì´ë“œë°” ë‹«ê¸°
            mapElement.addEventListener('wheel', (e) => {
                closeSidebar();
            });

            // ESC í‚¤ë¡œ ì„ íƒ í•´ì œ
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    // ì„ íƒëœ ê°ì²´ê°€ ìˆìœ¼ë©´ í•´ì œ
                    if (selectedObject || selectionPanel.style.display === 'block') {
                        // í•˜ì´ë¼ì´íŠ¸ ì œê±°
                        if (highlightedObjectId && selectedLayer) {
                            try {
                                const obj = selectedLayer.keyAtObject(highlightedObjectId);
                                if (obj && typeof obj.setHighlight === 'function') {
                                    obj.setHighlight(false);
                                }
                            } catch (err) {
                                console.log('í•˜ì´ë¼ì´íŠ¸ ì œê±° ì˜¤ë¥˜:', err.message);
                            }
                        }

                        selectedObject = null;
                        selectedLayer = null;
                        highlightedObjectId = null;
                        selectionPanel.style.display = 'none';
                        console.log('ESCë¡œ ì„ íƒ í•´ì œ');
                    }
                }
            });

            // ì„ íƒ ì •ë³´ íŒ¨ë„ ìƒì„±
            const selectionPanel = document.createElement('div');
            selectionPanel.id = 'selection-panel';
            selectionPanel.style.cssText = `
                position: fixed;
                right: 20px;
                bottom: 20px;
                background-color: #252526;
                border: 1px solid #3c3c3c;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                padding: 16px;
                min-width: 300px;
                max-width: 400px;
                max-height: 400px;
                overflow-y: auto;
                z-index: 3000;
                display: none;
                color: #cccccc;
                font-size: 13px;
            `;
            document.body.appendChild(selectionPanel);

            // ì§€ë„ í´ë¦­ ì‹œ ê°ì²´ ì„ íƒ
            let selectedObject = null;
            let selectedLayer = null;
            let highlightedObjectId = null;

            mapElement.addEventListener('click', (e) => {
                // ì‚¬ì´ë“œë°”ë‚˜ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´, ì„ íƒ íŒ¨ë„ í´ë¦­ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì²˜ë¦¬
                if (e.target.closest('#sidebar') ||
                    e.target.closest('.context-menu') ||
                    e.target.closest('#selection-panel')) {
                    return;
                }

                // í´ë¦­ ì¢Œí‘œ ê³„ì‚°
                const rect = mapElement.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                var screen_xy = new Module.JSVector2D(x, y);

                // 3DS ë°°ì¹˜ ëª¨ë“œ
                if (pending3DS && typeof Module !== 'undefined') {
                    console.log("pending3DS:",pending3DS);
                    // ScreenToWorldë¡œ í´ë¦­ ì§€ì ì˜ ê²½ìœ„ë„ ê°€ì ¸ì˜¤ê¸°                    
                        const sw = Module.getMap().ScreenToMapPointEX(screen_xy);
                        console.log("sw:",sw);
                        if (sw && sw.Longitude !== undefined) {                            
                            console.log('3DS ë°°ì¹˜: lon:', sw.Longitude, 'lat:', sw.Latitude, 'alt:', sw.Altitude);                            
                            load3DSAtPosition(pending3DS.filePath, pending3DS.fileName, sw);
                        }

                    cancel3DSPlacement();
                }

                console.log('ì§€ë„ í´ë¦­:', x, y);

                // XDWorld APIë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ì„ íƒ ì‹œë„
                try {
                    if (typeof Module !== 'undefined') {
                        // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                        if (highlightedObjectId && selectedLayer) {
                            try {
                                const oldObj = selectedLayer.keyAtObject(highlightedObjectId);
                                if (oldObj && typeof oldObj.setHighlight === 'function') {
                                    oldObj.setHighlight(false);
                                }
                            } catch (e) {
                                console.log('ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±° ì¤‘ ì˜¤ë¥˜:', e.message);
                            }
                        }

                        let pickedInfo = null;
                        let pickedObject = null;
                        let pickedLayer = null;
                        let worldPos = null;  // ìŠ¤ì½”í”„ í™•ì¥ì„ ìœ„í•´ ì—¬ê¸°ì„œ ì„ ì–¸

                        // ë°©ë²• 1: JSLayerì˜ getPickInfoAtView ë©”ì„œë“œ ì‚¬ìš©
                        // í™”ë©´ ì¢Œí‘œì—ì„œ ë ˆì´ ìƒì„±
                        const camera = Module.getViewCamera();
                        if (camera) {
                            // ì¹´ë©”ë¼ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
                            const cameraPos = camera.getLocation();

                            // í™”ë©´ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜ ì‹œë„
                            if (typeof Module.ScreenToWorld === 'function') {
                                worldPos = Module.ScreenToWorld(x, y);
                            } else if (typeof camera.screenToWorld === 'function') {
                                worldPos = camera.screenToWorld(x, y);
                            }

                            if (cameraPos && worldPos) {
                                console.log('ì¹´ë©”ë¼ ìœ„ì¹˜:', cameraPos, 'ì›”ë“œ ì¢Œí‘œ:', worldPos);

                                // ëª¨ë“  ë ˆì´ì–´ë¥¼ ìˆœíšŒí•˜ë©° í”¼í‚¹ ì‹œë„
                                const layerList = new Module.JSLayerList(true);
                                const layerCount = layerList.getCount();

                                for (let i = 0; i < layerCount; i++) {
                                    const layer = layerList.indexAtLayer(i);
                                    if (!layer || !layer.getVisible()) continue;

                                    // ë ˆì´ì–´ê°€ ì„ íƒ ê°€ëŠ¥í•œì§€ í™•ì¸
                                    if (typeof layer.getSelectable === 'function' && !layer.getSelectable()) {
                                        continue;
                                    }

                                    // getPickInfoAtView ë©”ì„œë“œ ì‚¬ìš©
                                    if (typeof layer.getPickInfoAtView === 'function') {
                                        try {
                                            const info = layer.getPickInfoAtView(cameraPos, worldPos);
                                            if (info && info.objectKey) {
                                                pickedInfo = info;
                                                pickedLayer = layer;
                                                console.log('í”¼í‚¹ ì„±ê³µ (getPickInfoAtView):', info);
                                                break;
                                            }
                                        } catch (e) {
                                            console.log('getPickInfoAtView ì˜¤ë¥˜:', e.message);
                                        }
                                    }
                                }

                                // pickedInfoì—ì„œ ì‹¤ì œ ê°ì²´ ê°€ì ¸ì˜¤ê¸°
                                if (pickedInfo && pickedInfo.objectKey && pickedLayer) {
                                    pickedObject = pickedLayer.keyAtObject(pickedInfo.objectKey);
                                    if (!pickedObject) {
                                        console.warn('objectKeyë¡œ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:', pickedInfo.objectKey);
                                    }
                                }
                            }
                        }

                        // ë°©ë²• 2: worldPosë¡œ ê·¼ì ‘ ê²€ìƒ‰ (ëŒ€ì²´ ë°©ë²•)
                        if (!pickedObject && worldPos) {
                            console.log('getPickInfoAtView ì‹¤íŒ¨. ê·¼ì ‘ ê²€ìƒ‰ ì‹œë„...');

                            const layerList = new Module.JSLayerList(true);
                            const layerCount = layerList.getCount();
                            let minDistance = Infinity;
                            let closestObject = null;
                            let closestLayer = null;

                            for (let i = 0; i < layerCount; i++) {
                                const layer = layerList.indexAtLayer(i);
                                if (!layer || !layer.getVisible()) continue;

                                const objectCount = layer.getCount();
                                for (let j = 0; j < objectCount; j++) {
                                    try {
                                        const obj = layer.indexAtObject(j);
                                        if (!obj) continue;

                                        // ê°ì²´ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
                                        let objPos = null;
                                        if (typeof obj.getPosition === 'function') {
                                            objPos = obj.getPosition();
                                        } else if (obj.position) {
                                            objPos = obj.position;
                                        }

                                        if (objPos) {
                                            // ê±°ë¦¬ ê³„ì‚°
                                            const dx = (objPos.longitude || objPos.x || 0) - (worldPos.longitude || worldPos.x || 0);
                                            const dy = (objPos.latitude || objPos.y || 0) - (worldPos.latitude || worldPos.y || 0);
                                            const distance = Math.sqrt(dx * dx + dy * dy);

                                            // ì„ê³„ê°’ ì´ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ê°ì²´ ì„ íƒ
                                            if (distance < 0.001 && distance < minDistance) {
                                                minDistance = distance;
                                                closestObject = obj;
                                                closestLayer = layer;
                                            }
                                        }
                                    } catch (e) {
                                        // ë¬´ì‹œ
                                    }
                                }
                            }

                            if (closestObject) {
                                pickedObject = closestObject;
                                pickedLayer = closestLayer;
                                console.log('ê·¼ì ‘ ê²€ìƒ‰ ì„±ê³µ:', closestObject, 'ê±°ë¦¬:', minDistance);
                            }
                        }

                        if (pickedObject) {
                            selectedObject = pickedObject;
                            selectedLayer = pickedLayer;
                            console.log('ì„ íƒëœ ê°ì²´:', pickedObject);

                            // ê°ì²´ ì •ë³´ í‘œì‹œ
                            displaySelectionInfo(pickedObject, pickedInfo);

                            // í•˜ì´ë¼ì´íŠ¸ ì ìš© ì‹œë„
                            if (typeof pickedObject.setHighlight === 'function') {
                                pickedObject.setHighlight(true);
                                highlightedObjectId = pickedObject.getId ? pickedObject.getId() : (pickedInfo ? pickedInfo.objectKey : null);
                            } else {
                                console.log('setHighlight ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ');
                            }
                        } else {
                            // ë¹ˆ ê³µê°„ í´ë¦­ - ì„ íƒ í•´ì œ
                            selectedObject = null;
                            selectedLayer = null;
                            highlightedObjectId = null;
                            selectionPanel.style.display = 'none';
                            console.log('ì„ íƒ í•´ì œ (ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ)');
                        }
                    }
                } catch (err) {
                    console.error('ê°ì²´ ì„ íƒ ì˜¤ë¥˜:', err);
                    console.error('ì˜¤ë¥˜ ìŠ¤íƒ:', err.stack);
                }
            });

            // ì„ íƒëœ ê°ì²´ ì •ë³´ í‘œì‹œ í•¨ìˆ˜
            function displaySelectionInfo(obj, pickInfo) {
                if (!obj) {
                    selectionPanel.style.display = 'none';
                    return;
                }

                let infoHTML = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">';
                infoHTML += '<h3 style="margin: 0; color: #ffffff; font-size: 14px; font-weight: 600;">ì„ íƒëœ ê°ì²´</h3>';
                infoHTML += '<button onclick="document.getElementById(\'selection-panel\').style.display=\'none\'" style="background: transparent; border: none; color: #cccccc; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px;">Ã—</button>';
                infoHTML += '</div>';

                // ë ˆì´ì–´ ì´ë¦„ (pickInfoì—ì„œ ê°€ì ¸ì˜¤ê¸°)
                if (pickInfo && pickInfo.layerName) {
                    infoHTML += `<div style="margin-bottom: 8px;"><span style="color: #858585;">ë ˆì´ì–´:</span> ${pickInfo.layerName}</div>`;
                }

                // ê°ì²´ íƒ€ì…
                let objType = 'ì•Œ ìˆ˜ ì—†ìŒ';
                if (typeof obj.getType === 'function') {
                    const type = obj.getType();
                    if (type === Module.ELT_3DPOINT) objType = 'ì  (Point)';
                    else if (type === Module.ELT_3DLINE) objType = 'ì„  (LineString)';
                    else if (type === Module.ELT_POLYHEDRON) objType = 'ë©´ (Polygon)';
                    else objType = `íƒ€ì…: ${type}`;
                } else {
                    // ê°ì²´ í´ë˜ìŠ¤ëª…ìœ¼ë¡œ íƒ€ì… ì¶”ì •
                    const className = obj.constructor ? obj.constructor.name : '';
                    if (className.includes('Point')) objType = 'ì  (Point)';
                    else if (className.includes('Line')) objType = 'ì„  (LineString)';
                    else if (className.includes('Polygon')) objType = 'ë©´ (Polygon)';
                }

                infoHTML += `<div style="margin-bottom: 8px;"><span style="color: #858585;">íƒ€ì…:</span> ${objType}</div>`;

                // ê°ì²´ ID/Key
                const objectId = pickInfo && pickInfo.objectKey ? pickInfo.objectKey : (typeof obj.getId === 'function' ? obj.getId() : obj.id);
                if (objectId) {
                    infoHTML += `<div style="margin-bottom: 8px;"><span style="color: #858585;">ID:</span> ${objectId}</div>`;
                }

                // ìœ„ì¹˜ ì •ë³´ (pickInfo.position ìš°ì„ , ì—†ìœ¼ë©´ obj.getPosition() ì‚¬ìš©)
                let pos = null;
                if (pickInfo && pickInfo.position) {
                    pos = pickInfo.position;
                } else if (typeof obj.getPosition === 'function') {
                    pos = obj.getPosition();
                } else if (obj.position) {
                    pos = obj.position;
                }

                if (pos) {
                    infoHTML += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #3c3c3c;">';
                    infoHTML += '<div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">ìœ„ì¹˜</div>';
                    if (pos.longitude !== undefined || pos.x !== undefined) {
                        const lon = pos.longitude !== undefined ? pos.longitude : pos.x;
                        infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">ê²½ë„:</span> ${lon.toFixed(6)}Â°</div>`;
                    }
                    if (pos.latitude !== undefined || pos.y !== undefined) {
                        const lat = pos.latitude !== undefined ? pos.latitude : pos.y;
                        infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">ìœ„ë„:</span> ${lat.toFixed(6)}Â°</div>`;
                    }
                    if (pos.altitude !== undefined || pos.z !== undefined) {
                        const alt = pos.altitude !== undefined ? pos.altitude : pos.z;
                        infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">ê³ ë„:</span> ${alt.toFixed(2)}m</div>`;
                    }
                    infoHTML += '</div>';
                }

                // ìŠ¤íƒ€ì¼ ì •ë³´ (ìƒ‰ìƒ ë“±)
                if (typeof obj.getStyle === 'function') {
                    const style = obj.getStyle();
                    if (style) {
                        infoHTML += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #3c3c3c;">';
                        infoHTML += '<div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">ìŠ¤íƒ€ì¼</div>';

                        // ìƒ‰ìƒ ì •ë³´
                        if (typeof style.getColor === 'function') {
                            const color = style.getColor();
                            if (color) {
                                infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">ìƒ‰ìƒ:</span> RGBA(${color.r || 0}, ${color.g || 0}, ${color.b || 0}, ${color.a || 255})</div>`;
                            }
                        }

                        // ì„  ë‘ê»˜
                        if (typeof style.getWidth === 'function') {
                            infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">ë‘ê»˜:</span> ${style.getWidth()}</div>`;
                        }

                        infoHTML += '</div>';
                    }
                }

                // ì†ì„± ì •ë³´ (GeoJSON properties ë“±)
                if (obj.properties) {
                    infoHTML += '<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #3c3c3c;">';
                    infoHTML += '<div style="color: #ffffff; font-weight: 600; margin-bottom: 8px;">ì†ì„±</div>';
                    for (const [key, value] of Object.entries(obj.properties)) {
                        infoHTML += `<div style="margin-bottom: 4px;"><span style="color: #858585;">${key}:</span> ${value}</div>`;
                    }
                    infoHTML += '</div>';
                }

                selectionPanel.innerHTML = infoHTML;
                selectionPanel.style.display = 'block';
            }

        });

        // ëœë¤ ìƒ‰ìƒ ìƒì„± í•¨ìˆ˜
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // ë ˆì´ì–´ ì•„ì´í…œ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥
        let draggedItem = null;

        // ë ˆì´ì–´ ìˆœì„œ ë™ê¸°í™” í•¨ìˆ˜
        function syncLayerOrder() {
            const container = document.getElementById('interface');
            const items = Array.from(container.children);

            // ê° ë ˆì´ì–´ ì•„ì´í…œì˜ í˜„ì¬ ìœ„ì¹˜ì™€ layer ê°ì²´ë¥¼ ìˆ˜ì§‘
            const layerData = items.map((item, index) => ({
                item: item,
                layer: item._xdLayer,
                layerList: item._xdLayerList,
                currentIndex: index
            })).filter(data => data.layer && data.layerList);

            // ë ˆì´ì–´ ìˆœì„œë¥¼ DOM ìˆœì„œì— ë§ê²Œ ì¬ì •ë ¬
            // ë§¨ ë’¤ë¶€í„° ì‹œì‘í•´ì„œ ê° ë ˆì´ì–´ë¥¼ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ë¡œ ì´ë™
            for (let i = layerData.length - 1; i >= 0; i--) {
                const data = layerData[i];
                // ë ˆì´ì–´ë¥¼ ë§¨ ë’¤ë¡œ ë³´ë‚¸ ë‹¤ìŒ, í•„ìš”í•œ ë§Œí¼ ì•ìœ¼ë¡œ ì´ë™
                data.layerList.setLayerTopNBottom(data.layer, false); // ë§¨ ë’¤ë¡œ
            }

            // ì´ì œ ì—­ìˆœìœ¼ë¡œ ë‹¤ì‹œ ì •ë ¬ (ë§¨ ì•ë¶€í„°)
            for (let i = 0; i < layerData.length; i++) {
                const data = layerData[i];
                // ië²ˆ ë°˜ë³µí•´ì„œ ì•ìœ¼ë¡œ ì´ë™
                for (let j = 0; j < layerData.length - 1 - i; j++) {
                    data.layerList.setLayerMove(data.layer, true); // ì•ìœ¼ë¡œ ì´ë™
                }
            }
        }

        function makeDraggable(layerItem, layer, layerList) {
            // ë ˆì´ì–´ ê°ì²´ë¥¼ ì•„ì´í…œì— ì €ì¥
            layerItem._xdLayer = layer;
            layerItem._xdLayerList = layerList;

            layerItem.draggable = true;
            layerItem.style.cursor = 'move';

            layerItem.addEventListener('dragstart', (e) => {
                draggedItem = layerItem;
                layerItem.style.opacity = '0.5';
                e.dataTransfer.effectAllowed = 'move';
            });

            layerItem.addEventListener('dragend', (e) => {
                layerItem.style.opacity = '1';
                draggedItem = null;

                // ë“œë˜ê·¸ê°€ ëë‚˜ë©´ ë ˆì´ì–´ ìˆœì„œ ë™ê¸°í™”
                syncLayerOrder();
            });

            layerItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                if (draggedItem && draggedItem !== layerItem) {
                    const container = layerItem.parentNode;
                    const items = Array.from(container.children);
                    const draggedIndex = items.indexOf(draggedItem);
                    const targetIndex = items.indexOf(layerItem);

                    if (draggedIndex < targetIndex) {
                        layerItem.after(draggedItem);
                    } else {
                        layerItem.before(draggedItem);
                    }
                }
            });

            layerItem.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        }

        // íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ (ê³µí†µ ë¡œì§)
        function processFilePath(filePath) {
            // íŒŒì¼ ê²½ë¡œì—ì„œ file:/// ì ‘ë‘ì–´ ì œê±°
            if (filePath.startsWith("file:///")) {
                filePath = filePath.replace("file:///", "");
            } else if (filePath.startsWith("File:///")) {
                filePath = filePath.replace("File:///", "");
            }
            filePath = filePath.replace(/\\/g, '/'); // ì—­ìŠ¬ë˜ì‹œë¥¼ ìŠ¬ë˜ì‹œë¡œ ë³€ê²½
            if (filePath.endsWith('.las')) {
                const info = window.electronAPI.parseLASHeader(filePath);
                const fileName = filePath.split(/[/\\]/).pop(); // sample.las

                if (info) {
                    console.log('LAS-í¬ì¸íŠ¸ìˆ˜:', info.pointCount);
                    console.log('Bounding Box:', info.bbox);
                    alert(
                        'í˜„ì¬ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.\n' + filePath + '\n' +
                        'í—ˆìš©ëœ íŒŒì¼: .geojson, .meta, tileset.json\n\n' +
                        'LAS ìš”ì•½ì •ë³´\n' +
                        'ì „ì²´í¬ì¸íŠ¸ìˆ˜: ' + info.pointCount + '\n' +
                        'Bounding Box: ' + JSON.stringify(info.bbox) + '\n\n' +
                        '3DTiles(PNTS)ë¡œ ë³€í™˜í•˜ë ¤ë©´:\n' +
                        'npm install -g @cesium/3d-tiles-tools\n' +
                        '3d-tiles-tools las2pnts --input ' + filePath + ' --output output_folder'
                    );
                }else{
                    alert('LAS íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }

            }
            if(filePath.endsWith('.tif') || filePath.endsWith('.tiff')) {
                window.electronAPI.parseTIFHeader(filePath)
                .then(info => {
                    if (info) {
                        console.log(info);
                        alert(
                            'í˜„ì¬ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.\n' + filePath + '\n' +
                            'TIF ê¸°ë³¸ì •ë³´\n' +
                            'í¬ê¸°: ' + info.width + ' x ' + info.height + '\n' +
                            'Bounding Box: ' + JSON.stringify(info.bbox) + '\n' +
                            'Samples Per Pixel: ' + info.samplesPerPixel + '\n' +
                            'Bits Per Sample: ' + info.bitsPerSample
                        );
                    } else {
                        alert('TIF íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                });
                
            }
            if (filePath.endsWith('tileset.json')) {
                // tileset.json íŒŒì¼ì´ë©´ 3DTILES ë ˆì´ì–´ë¡œ ì¶”ê°€
                let layerList = new Module.JSLayerList(true);
                // ìƒìœ„ í´ë”ëª… ì¶”ì¶œ
                let pathParts = filePath.split(/[\\/]/);
                let parentFolder = pathParts.length > 1 ? pathParts[pathParts.length - 2] : '_LAYER_' + index;
                let layer = layerList.createLayer(parentFolder, Module.ELT_3DTILES);
                layer.import3DTiles({
                    url: filePath,
                    autoMove: true,
                    offsetZ: 2.0
                });
                layer.setPointCloudPointSize(2.0); // í¬ì¸íŠ¸ í´ë¼ìš°ë“œ í¬ê¸° ì„¤ì •

                // ìƒˆ ë ˆì´ì–´ UI ìƒì„±
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';

                // ì²´í¬ë°•ìŠ¤
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    layer.setVisible(checkbox.checked);
                });

                // ë ˆì´ì–´ ì´ë¦„
                const label = document.createElement('span');
                label.textContent = parentFolder;
                label.title = parentFolder; // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ì „ì²´ ì´ë¦„ í‘œì‹œ
                label.style.cursor = 'pointer'; // í´ë¦­ ê°€ëŠ¥í•¨ì„ í‘œì‹œ
                label.addEventListener('click', () => {
                    try {
                        const jsonData = window.electronAPI.readJsonFile(filePath);
                        const trs = jsonData?.root?.transform;
                        const region = jsonData?.root?.boundingVolume?.region;

                        if (region && region.length >= 6) {
                            // region [west, south, east, north, minH, maxH] (ë¼ë””ì•ˆ) - ê°€ì¥ ì •í™•
                            const RAD2DEG = 180 / Math.PI;
                            const cenLon = ((region[0] + region[2]) / 2) * RAD2DEG;
                            const cenLat = ((region[1] + region[3]) / 2) * RAD2DEG;
                            const cenAlt = region[5] || 500;
                            Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, cenAlt + 1000), 89.9, 0, 0);
                        } else if (trs && trs.length >= 15) {
                            // transformì—ì„œ ECEF â†’ ê²½ìœ„ë„ ë³€í™˜ (region ì—†ì„ ë•Œ í´ë°±)
                            const lla = ecefToLla(trs[12], trs[13], trs[14]);
                            Module.getViewCamera().move(new Module.JSVector3D(lla.lonDeg, lla.latDeg, lla.h + 1000), 89.9, 0, 0);
                        } else {
                            console.warn('tileset.jsonì— ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        }
                    } catch (e) {
                        console.error('tileset.json ì½ê¸° ì˜¤ë¥˜:', e.message);
                    }
                });

                // x ì œê±° ë²„íŠ¼
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                removeBtn.title = `${label.textContent} ë ˆì´ì–´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤`;
                removeBtn.addEventListener('click', () => {
                    Module.XDEMapRemoveLayer(label.textContent);
                    layerItem.remove();
                    mouseOverInterface(false);
                });

                // ì¡°ë¦½
                layerItem.appendChild(checkbox);
                layerItem.appendChild(label);
                layerItem.appendChild(removeBtn);

                // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì¶”ê°€
                layerItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    window.currentContextLayer = {
                        layerItem: layerItem,
                        layer: layer,
                        label: label,
                        removeBtn: removeBtn
                    };

                    showContextMenu(e, layerItem);
                });

                // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                makeDraggable(layerItem, layer, layerList);

                document.getElementById('interface').appendChild(layerItem);
                index++;
            } else if (filePath.endsWith('.geojson')) {
                loadGeojsonLayer(filePath);
            } else if (filePath.endsWith('.csv')) {
                loadCsvLayer(filePath);
            } else if (filePath.endsWith('.glb') || filePath.endsWith('.gltf')) {
                loadGltfLayer(filePath);
            } else if (filePath.toLowerCase().endsWith('.3ds')) {
                start3DSPlacement(filePath);
            } else if (filePath.endsWith('.meta')) {
                loadMetaLayer(filePath);
            }
        }
        
        // Electronì—ì„œ íŒŒì¼ ê²½ë¡œ ìˆ˜ì‹  ì‹œ ì²˜ë¦¬
        window.electronAPI.onFilePathReceived((event, filePaths) => {
            // ì—¬ëŸ¬ íŒŒì¼ì„ ë°›ì„ ìˆ˜ ìˆë„ë¡ filePaths ë°°ì—´ë¡œ ì²˜ë¦¬
            if (!Array.isArray(filePaths)) {
                filePaths = [filePaths];
            }
            filePaths.forEach(processFilePath);
        });

        // íŒŒì¼ ì„ íƒ ë²„íŠ¼ í´ë¦­ ì‹œ ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì— íŒŒì¼ ì„ íƒ ìš”ì²­
        document.getElementById('openLayer').addEventListener('click', async () => {

            window.electronAPI.openFileDialog({
                filters: [
                    { name: 'JSON/GeoJSON Files', extensions: ['json', 'geojson'] },
                    { name: 'Layer', extensions: ['meta'] }
                ],
                properties: ['openFile']
            }); // ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì˜ íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ í˜¸ì¶œ
        });

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥ ì¶”ê°€
        // Document ë ˆë²¨ì—ì„œ ê¸°ë³¸ ë“œë˜ê·¸ ë™ì‘ ë°©ì§€ (Electronì—ì„œ í•„ìˆ˜)
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        // body ì „ì²´ì— ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì ìš©
        const dropZone = document.body;

        // dragenter ì´ë²¤íŠ¸ ì¶”ê°€
        dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Drag enter detected');
            document.getElementById('map').classList.add('dragover');
        }, false);

        // ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ê¸°ë³¸ ë™ì‘ ë°©ì§€ ë° ì‹œê°ì  í”¼ë“œë°±
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, false);

        // ë“œë˜ê·¸ê°€ ì˜ì—­ì„ ë– ë‚  ë•Œ ì‹œê°ì  í”¼ë“œë°± ì œê±°
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // ì™„ì „íˆ ë– ë‚¬ì„ ë•Œë§Œ ì œê±° (ìì‹ ìš”ì†Œë¡œ ì´ë™í•˜ëŠ” ê²½ìš° ì œì™¸)
            if (e.target === dropZone) {
                console.log('Drag leave detected');
                document.getElementById('map').classList.remove('dragover');
            }
        }, false);

        // íŒŒì¼ í™•ì¥ì ê²€ì¦ í•¨ìˆ˜
        function isValidFileType(filePath) {
            const validExtensions = ['.geojson', '.meta', '.las', '.tif', '.tiff', '.csv', '.glb', '.gltf', '.3ds'];
            const fileName = filePath.toLowerCase();

            // tileset.json ì²´í¬
            if (fileName.endsWith('tileset.json')) {
                return true;
            }

            // ë‹¤ë¥¸ í—ˆìš© í™•ì¥ì ì²´í¬
            return validExtensions.some(ext => fileName.endsWith(ext));
        }

        // íŒŒì¼ ë“œë¡­ ì‹œ ì²˜ë¦¬
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Drop detected');
            document.getElementById('map').classList.remove('dragover');

            const files = e.dataTransfer.files;
            console.log('Dropped files:', files.length);

            if (files && files.length > 0) {
                let validFileCount = 0;
                let invalidFiles = [];

                // Electronì˜ webUtilsë¥¼ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
                Array.from(files).forEach(file => {
                    const filePath = window.electronAPI.getPathForFile(file);
                    console.log('File path:', filePath);

                    if (filePath) {
                        // íŒŒì¼ í˜•ì‹ ê²€ì¦
                        if (isValidFileType(filePath)) {
                            processFilePath(filePath);
                            validFileCount++;
                        } else {
                            invalidFiles.push(file.name);
                        }
                    }
                });

                // ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ì´ ìˆìœ¼ë©´ ì•Œë¦¼
                if (invalidFiles.length > 0) {
                    alert('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.\ní—ˆìš©ëœ íŒŒì¼: .geojson, .csv, .meta, tileset.json\n\nì˜ëª»ëœ íŒŒì¼:\n' + invalidFiles.join('\n'));
                }

                console.log(`Valid files processed: ${validFileCount}, Invalid files: ${invalidFiles.length}`);
            }
        }, false);

        // ì¸í„°í˜ì´ìŠ¤ ë§ˆìš°ìŠ¤ ì˜¤ë²„ ìƒíƒœ ì„¤ì •
        function mouseOverInterface(_isOver) {
            if (typeof Module == "object") {
                Module.XDIsMouseOverDiv(_isOver);
            }
        }

        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ì²˜ë¦¬
        window.onresize = function (e) {
            if (typeof Module == 'object') {
                if (typeof Module.Resize == 'function') {
                    const mapHeight = bottomPanelVisible ? window.innerHeight - bottomPanelHeight : window.innerHeight;
                    Module.Resize(window.innerWidth, mapHeight);
                    Module.XDRenderData();
                }
            }
            if (bottomPanelVisible) updateMapSize();
        };

        // XDWorld ëª¨ë“ˆ ì„¤ì •
        var Module = {
            locateFile: function (s) {
                return "https://cdn.xdworld.kr/latest/" + s; // ëª¨ë“ˆ íŒŒì¼ ê²½ë¡œ ì„¤ì •
            },
            postRun: function () {
                Module.initialize({
                    container: document.getElementById("map"), // ì§€ë„ ì»¨í…Œì´ë„ˆ ì„¤ì •
                    terrain: {
                        dem: {
                            url: "https://xdworld.vworld.kr",
                            name: "dem",
                            servername: "XDServer3d",
                            encoding: true
                        },
                        image: {
                            url: "https://xdworld.vworld.kr",
                            name: "tile",
                            servername: "XDServer3d"
                        }
                    },
                    worker: {
                        use: true, // ì›Œì»¤ ì‚¬ìš© ì—¬ë¶€
                        path: "./worker/XDWorldWorker.js", // ì›Œì»¤ íŒŒì¼ ê²½ë¡œ
                        count: 5 // ì›Œì»¤ ìˆ˜
                    },
                    defaultKey: "dJe!e!iaEpHmEpCrD5QpEQf2#FBrdzDmd(BQDQEQDJdaE(iB"
                });

                // ë¡œë”© í™”ë©´ í¬ë¡œìŠ¤ í˜ì´ë“œ (3ì´ˆ í›„)
                setTimeout(function () {
                    const loadingScreen = document.getElementById('loading-screen');
                    loadingScreen.classList.add('fade-out');
                    // í˜ì´ë“œ ì•„ì›ƒì´ ì™„ì „íˆ ëë‚œ í›„ ì œê±°
                    setTimeout(function () {
                        loadingScreen.style.display = 'none';
                    }, 1500); // fade-out ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ê³¼ ë™ì¼ (1.5ì´ˆ)
                }, 3000); // ë¡œë”© ì™„ë£Œ í›„ 3ì´ˆ ëŒ€ê¸°

                /*
                                // ê¸°ë³¸ íƒ€ì¼ ë ˆì´ì–´ ì„¤ì •
                                var layerSimple = Module.getTileLayerList().createXDServerLayer({
                                    url: "https://xdworld.vworld.kr",
                                    servername: "XDServer3d",
                                    name: "facility_build",
                                    type: 9,
                                    minLevel: 0,
                                    maxLevel: 15
                                });
                                Module.setVisibleRange("facility_build", 3.0, 100000.0); // ê°€ì‹œ ë²”ìœ„ ì„¤ì •
                
                                // ê°„ë‹¨ ëª¨ë“œ ì„¤ì •
                                Module.getMap().setSimpleMode(true);
                                Module.getViewCamera().setLocation(new Module.JSVector3D(126.9, 37.5, 300.0)); // ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì •
                                Module.getViewCamera().setTilt(30); // ì¹´ë©”ë¼ ê¸°ìš¸ê¸° ì„¤ì •
                */

                // SQLite ë° í•˜ë‹¨ íŒ¨ë„ ì´ˆê¸°í™”
                initSqlite();
                initBottomPanel();
            }
        };

        // XDWorld ìŠ¤í¬ë¦½íŠ¸ ë™ì  ë¡œë“œ
        var script = document.createElement('script');
        script.src = "https://cdn.xdworld.kr/latest/XDWorldEM.js";
        document.body.appendChild(script);

        function createPointObjects(layer, features, altitude, color, customIconUrl, pointSize = 10) {
            var layerName = layer.getName();

            if (customIconUrl) {
                // ì»¤ìŠ¤í…€ ì•„ì´ì½˜ ì‚¬ìš© - Symbol ì‹œìŠ¤í…œìœ¼ë¡œ ì•„ì´ì½˜ ë“±ë¡
                const iconName = layerName + '_custom_' + Date.now();
                const img = new Image();

                img.onload = function () {
                    // ì  í¬ê¸°ì— ë”°ë¼ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                    const canvasSize = Math.max(48, pointSize * 2);
                    const canvas = document.createElement('canvas');
                    canvas.width = canvasSize;
                    canvas.height = canvasSize;
                    const ctx = canvas.getContext('2d');

                    // íˆ¬ëª… ë°°ê²½
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // ì´ë¯¸ì§€ë¥¼ ë¹„ìœ¨ì— ë§ì¶° ì¤‘ì•™ì— ê·¸ë¦¬ê¸°
                    const maxSize = Math.max(40, pointSize * 1.6);
                    const imgWidth = img.width;
                    const imgHeight = img.height;
                    const aspectRatio = imgWidth / imgHeight;

                    let drawWidth, drawHeight, offsetX, offsetY;

                    if (aspectRatio > 1) {
                        // ê°€ë¡œê°€ ë” ê¸´ ê²½ìš°
                        drawWidth = maxSize;
                        drawHeight = maxSize / aspectRatio;
                    } else {
                        // ì„¸ë¡œê°€ ë” ê¸´ ê²½ìš° (í•€ ë“±)
                        drawHeight = maxSize;
                        drawWidth = maxSize * aspectRatio;
                    }

                    offsetX = (canvas.width - drawWidth) / 2;
                    offsetY = (canvas.height - drawHeight) / 2;

                    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Symbol ì‹œìŠ¤í…œì— ì•„ì´ì½˜ ë“±ë¡
                    if (Module.getSymbol().insertIcon(iconName, imageData.data, canvas.width, canvas.height)) {
                        const iconObject = Module.getSymbol().getIcon(iconName);

                        // Point ê°ì²´ ìƒì„± ë° ì•„ì´ì½˜ ì„¤ì •
                        for (let i = 0; i < features.length; i++) {
                            try {
                                let feature = features[i];
                                let coords = feature.geometry.coordinates;
                                if (!Array.isArray(coords) || coords.length < 2) continue;
                                let id = feature.id || "GEOJSON_POINT_" + i;
                                let lon = coords[0];
                                let lat = coords[1];
                                let alt = coords.length >= 3 ? coords[2] : altitude;

                                let point = Module.createPoint(id);
                                point.setPosition(new Module.JSVector3D(lon, lat, alt + 1.5));
                                point.setIcon(iconObject);
                                point.setVisibleRange(true, 0.0, 500000.0);
                                // í…ìŠ¤íŠ¸ í‘œì‹œ
                                const label = feature.properties?.name || '';
                                if (label) {
                                    point.setText(label);
                                    point.setFontStyle('ë§‘ì€ ê³ ë”•', 12, 'bold',
                                        new Module.JSColor(255, 255, 255, 255),
                                        new Module.JSColor(200, 0, 0, 0));
                                }
                                layer.addObject(point, 0);
                            } catch (e) {
                                console.error(`í¬ì¸íŠ¸ ${i} ìƒì„± ì˜¤ë¥˜:`, e.message);
                            }
                        }
                        layer.rebuildObjectLayer();
                    }
                };

                img.onerror = function () {
                    console.error("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:", customIconUrl);
                };

                img.src = customIconUrl;
            } else {
                // ê¸°ë³¸ ìƒ‰ìƒ ì  ì•„ì´ì½˜ - Symbol ì‹œìŠ¤í…œ ì‚¬ìš©
                const iconName = layerName + '_circle_' + Date.now();
                const canvas = document.createElement('canvas');
                // ì  í¬ê¸°ì— ë”°ë¼ ìº”ë²„ìŠ¤ì™€ ë°˜ì§€ë¦„ ì¡°ì •
                const canvasSize = Math.max(24, pointSize * 3);
                const radius = Math.max(3, pointSize / 2);
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const ctx = canvas.getContext('2d');

                // ì  ê·¸ë¦¬ê¸°
                ctx.clearRect(0, 0, canvasSize, canvasSize);
                ctx.beginPath();
                ctx.arc(canvasSize / 2, canvasSize / 2, radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = color;
                ctx.fill();

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Symbol ì‹œìŠ¤í…œì— ì•„ì´ì½˜ ë“±ë¡
                if (Module.getSymbol().insertIcon(iconName, imageData.data, canvas.width, canvas.height)) {
                    const iconObject = Module.getSymbol().getIcon(iconName);

                    for (let i = 0; i < features.length; i++) {
                        try {
                            let feature = features[i];
                            let coords = feature.geometry.coordinates;
                            if (!Array.isArray(coords) || coords.length < 2) continue;
                            let id = feature.id || "GEOJSON_POINT_" + i;
                            let lon = coords[0];
                            let lat = coords[1];
                            let alt = coords.length >= 3 ? coords[2] : altitude;

                            let point = Module.createPoint(id);
                            point.setPosition(new Module.JSVector3D(lon, lat, alt + 1.5));
                            point.setIcon(iconObject);
                            point.setVisibleRange(true, 0.0, 500000.0);
                            // í…ìŠ¤íŠ¸ í‘œì‹œ
                            const label = feature.properties?.name || '';
                            if (label) {
                                point.setText(label);
                                point.setFontStyle('ë§‘ì€ ê³ ë”•', 12, 'bold',
                                    new Module.JSColor(255, 255, 255, 255),
                                    new Module.JSColor(200, 0, 0, 0));
                            }
                            layer.addObject(point, 0);
                        } catch (e) {
                            console.error(`í¬ì¸íŠ¸ ${i} ìƒì„± ì˜¤ë¥˜ (ì›í˜•):`, e.message);
                        }
                    }
                    layer.rebuildObjectLayer();
                }
            }
        }

        function createLineObjects(layer, features, altitude, color, width = 3.0, transparency = 0) {
            for (let i = 0; i < features.length; i++) {
                try {
                    const feature = features[i];
                    const geometry = feature.geometry;
                    if (!geometry || !geometry.coordinates) continue;

                    const id = feature.id || `GEOJSON_LINE_${i}`;
                    const line = Module.createLineString(id);

                    const vertexList = new Module.JSVec3Array();
                    const partList = new Module.Collection();

                    if (geometry.type === "LineString") {
                        partList.addItem(geometry.coordinates.length);
                        geometry.coordinates.forEach(coord => {
                            const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                            vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                        });
                    }
                    else if (geometry.type === "MultiLineString") {
                        for (const part of geometry.coordinates) {
                            partList.add(part.length);
                            for (const coord of part) {
                                const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                                vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                            }
                        }
                    }
                    // ìŠ¤íƒ€ì¼ ì§€ì •
                    var style = new Module.JSPolyLineStyle();
                    style.setWidth(width);
                    const rgb = colorStringToRGB(color);
                    // íˆ¬ëª…ë„ë¥¼ Alpha ê°’ìœ¼ë¡œ ë³€í™˜: íˆ¬ëª…ë„ 0% = Alpha 255, íˆ¬ëª…ë„ 100% = Alpha 0
                    const alpha = Math.round(255 - (transparency * 2.55));
                    console.log('ë¼ì¸ ìƒ‰ìƒ (ì›ë³¸):', color, 'â†’ RGB:', rgb, 'íˆ¬ëª…ë„:', transparency + '%', 'â†’ Alpha:', alpha, 'ë‘ê»˜:', width);
                    // JSColorëŠ” ARGB ìˆœì„œ: (Alpha, Red, Green, Blue)
                    style.setColor(new Module.JSColor(alpha, rgb[0], rgb[1], rgb[2]));
                    line.setStyle(style);

                    line.setPartCoordinates(vertexList, partList);
                    layer.addObject(line, 0);
                } catch (e) {
                    console.error(`ë¼ì¸ ${i} ìƒì„± ì˜¤ë¥˜:`, e.message);
                }
            }
            layer.rebuildObjectLayer();
        }

        function createPolygonObjects(layer, features, altitude, color, strokeColor, fillTransparency = 0, strokeTransparency = 0) {
            for (let i = 0; i < features.length; i++) {
                try {
                    const feature = features[i];
                    const geometry = feature.geometry;
                    if (!geometry || !geometry.coordinates) continue;

                    const id = feature.id || `GEOJSON_POLY_${i}`;

                    if (geometry.type === "Polygon") {
                        createSinglePolygon(id, geometry.coordinates, color, altitude, layer, strokeColor, fillTransparency, strokeTransparency);
                    }
                    else if (geometry.type === "MultiPolygon") {
                        for (let j = 0; j < geometry.coordinates.length; j++) {
                            const partId = `${id}_part${j}`;
                            createSinglePolygon(partId, geometry.coordinates[j], color, altitude, layer, strokeColor, fillTransparency, strokeTransparency);
                        }
                    }
                } catch (e) {
                    console.error(`í´ë¦¬ê³¤ ${i} ìƒì„± ì˜¤ë¥˜:`, e.message);
                }
            }
            layer.rebuildObjectLayer();
        }

        function createSinglePolygon(id, rings, color, altitude, layer, strokeColor, fillTransparency = 0, strokeTransparency = 0) {
            const polygon = Module.createPolygon(id);
            const allVertices = new Module.Collection();

            // ì™¸ê³½ì„ ë§Œ ì¶”ê°€ (ë‚´ë¶€ ë§ì€ ë¬´ì‹œ)
            const outerRing = rings[0];
            outerRing.forEach(coord => {
                const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                allVertices.add(new Module.JSVector3D(x, y, z + 1.5));
            });

            const style = new Module.JSPolygonStyle();
            style.setFill(true);
            const fillRGB = colorStringToRGB(color);
            // íˆ¬ëª…ë„ë¥¼ Alpha ê°’ìœ¼ë¡œ ë³€í™˜: íˆ¬ëª…ë„ 0% = Alpha 255, íˆ¬ëª…ë„ 100% = Alpha 0
            const fillAlpha = Math.round(255 - (fillTransparency * 2.55));
            console.log('í´ë¦¬ê³¤ ë©´ ìƒ‰ìƒ (ì›ë³¸):', color, 'â†’ RGB:', fillRGB, 'íˆ¬ëª…ë„:', fillTransparency + '%', 'â†’ Alpha:', fillAlpha);
            // JSColorëŠ” ARGB ìˆœì„œ: (Alpha, Red, Green, Blue)
            style.setFillColor(new Module.JSColor(fillAlpha, fillRGB[0], fillRGB[1], fillRGB[2]));

            // ë¼ì¸ ìƒ‰ìƒ ì„¤ì •
            if (strokeColor) {
                const strokeRGB = colorStringToRGB(strokeColor);
                const strokeAlpha = Math.round(255 - (strokeTransparency * 2.55));
                console.log('í´ë¦¬ê³¤ ì„  ìƒ‰ìƒ (ì›ë³¸):', strokeColor, 'â†’ RGB:', strokeRGB, 'íˆ¬ëª…ë„:', strokeTransparency + '%', 'â†’ Alpha:', strokeAlpha);
                try {
                    // í´ë¦¬ê³¤ ì™¸ê³½ì„ ì„ ê·¸ë¦¬ë ¤ë©´ setOutLineì„ ë¨¼ì € í˜¸ì¶œí•´ì•¼ í•  ìˆ˜ ìˆìŒ
                    if (typeof style.setOutLine === 'function') {
                        style.setOutLine(true);
                        console.log('setOutLine(true) í˜¸ì¶œ ì„±ê³µ');
                    }

                    // JSColorëŠ” ARGB ìˆœì„œ: (Alpha, Red, Green, Blue)
                    const lineColor = new Module.JSColor(strokeAlpha, strokeRGB[0], strokeRGB[1], strokeRGB[2]);

                    // ë§¤ë‰´ì–¼ì— ë”°ë¼ setOutLineColor ë©”ì„œë“œ ì‚¬ìš© (ëŒ€ë¬¸ì L)
                    if (typeof style.setOutLineColor === 'function') {
                        style.setOutLineColor(lineColor);
                        console.log('setOutLineColor í˜¸ì¶œ ì„±ê³µ');
                    } else if (typeof style.setOutlineColor === 'function') {
                        style.setOutlineColor(lineColor);
                        console.log('setOutlineColor í˜¸ì¶œ ì„±ê³µ');
                    } else if (typeof style.setStrokeColor === 'function') {
                        style.setStrokeColor(lineColor);
                        console.log('setStrokeColor í˜¸ì¶œ ì„±ê³µ');
                    } else if (typeof style.setLineColor === 'function') {
                        style.setLineColor(lineColor);
                        console.log('setLineColor í˜¸ì¶œ ì„±ê³µ');
                    } else {
                        console.log('í´ë¦¬ê³¤ ì„  ìƒ‰ìƒ ì„¤ì • ë©”ì„œë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                    }

                    if (typeof style.setOutLineWidth === 'function') {
                        style.setOutLineWidth(2.0);
                        console.log('í´ë¦¬ê³¤ ì„  ë‘ê»˜ ì„¤ì • ì™„ë£Œ - OutLineWidth: 2.0');
                    } else if (typeof style.setLineWidth === 'function') {
                        style.setLineWidth(2.0);
                        console.log('í´ë¦¬ê³¤ ì„  ë‘ê»˜ ì„¤ì • ì™„ë£Œ - LineWidth: 2.0');
                    } else if (typeof style.setOutlineWidth === 'function') {
                        style.setOutlineWidth(2.0);
                        console.log('í´ë¦¬ê³¤ ì„  ë‘ê»˜ ì„¤ì • ì™„ë£Œ - OutlineWidth: 2.0');
                    }
                } catch (e) {
                    console.error('í´ë¦¬ê³¤ ì„  ì„¤ì • ì˜¤ë¥˜:', e.message);
                }
            } else {
                console.log('strokeColorê°€ ì œê³µë˜ì§€ ì•ŠìŒ');
            }

            polygon.setStyle(style);
            polygon.setCoordinates(allVertices);

            layer.addObject(polygon, 0);
        }

        function colorStringToRGB(rgbaStr) {
            // ì˜ˆ: "rgba(123, 234, 45, 1.0)" â†’ [123, 234, 45]
            const matches = rgbaStr.match(/\d+(\.\d+)?/g);
            if (!matches || matches.length < 3) return [0, 0, 0];
            return [parseInt(matches[0]), parseInt(matches[1]), parseInt(matches[2])];
        }

        // XDWorldì—ì„œ ì‚¬ìš©í•˜ëŠ” BGR ìƒ‰ìƒì„ RGB rgba ë¬¸ìì—´ë¡œ ë³€í™˜
        function convertToBGRColor(rgbaStr) {
            // XDWorldëŠ” BGR ìˆœì„œë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ì‹¤ì œ ì§€ë„ì— ê·¸ë ¤ì§€ëŠ” ìƒ‰ìƒì„ ë°˜í™˜
            const rgb = colorStringToRGB(rgbaStr);
            // Rê³¼ Bë¥¼ êµì²´ (BGRë¡œ ë³€í™˜ëœ ê²°ê³¼ë¥¼ RGBë¡œ ë‹¤ì‹œ í‘œí˜„)
            return `rgba(${rgb[2]}, ${rgb[1]}, ${rgb[0]}, 1.0)`;
        }

        function getMarkerIcon(_id, _color, returnDataUrl, type, transparency = 0, strokeColor = null, strokeTransparency = 0) {
            var canvas = document.createElement('canvas');
            var size = 16;
            canvas.width = size;
            canvas.height = size;

            var ctx = canvas.getContext('2d');

            if (type == 0) {
                // ì 
                const alpha = 1.0 - (transparency / 100);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI, false);
                ctx.fillStyle = _color;
                ctx.fill();
            } else if (type == 1) {
                // ì„ 
                const alpha = 1.0 - (transparency / 100);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.moveTo(0, size / 2);
                ctx.lineTo(size, size / 2);
                ctx.strokeStyle = _color;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else if (type == 2) {
                // í´ë¦¬ê³¤ (ë©´ + ì„ ì„ ê°ê° ë‹¤ë¥¸ íˆ¬ëª…ë„ë¡œ)
                ctx.beginPath();
                ctx.moveTo(2, 2);
                ctx.lineTo(size - 2, 2);
                ctx.lineTo(size - 2, size - 2);
                ctx.lineTo(2, size - 2);
                ctx.closePath();

                // ë©´ ë¨¼ì € ê·¸ë¦¬ê¸° (ë©´ íˆ¬ëª…ë„ ì ìš©)
                const fillAlpha = 1.0 - (transparency / 100);
                ctx.globalAlpha = fillAlpha;
                ctx.fillStyle = _color;
                ctx.fill();

                // ì„  ê·¸ë¦¬ê¸° (ì„  ìƒ‰ìƒê³¼ íˆ¬ëª…ë„ ì ìš©)
                if (strokeColor) {
                    const strokeAlpha = 1.0 - (strokeTransparency / 100);
                    ctx.globalAlpha = strokeAlpha;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }


            if (returnDataUrl) {
                return canvas.toDataURL();
            }

            if (Module.getSymbol().insertIcon(_id, ctx.getImageData(0, 0, canvas.width, canvas.height).data, canvas.width, canvas.height)) {
                return Module.getSymbol().getIcon(_id);
            }
            return null;
        }



        // ============ CSV ì²˜ë¦¬ ============

        // CSV í…ìŠ¤íŠ¸ë¥¼ 2D ë°°ì—´ë¡œ íŒŒì‹±
        function parseCSV(text) {
            const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const result = [];
            for (const line of lines) {
                if (line.trim() === '') continue;
                // ì‰¼í‘œ êµ¬ë¶„, í°ë”°ì˜´í‘œ ë‚´ ì‰¼í‘œ ì²˜ë¦¬
                const row = [];
                let cell = '';
                let inQuote = false;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (inQuote) {
                        if (ch === '"' && line[i + 1] === '"') {
                            cell += '"';
                            i++;
                        } else if (ch === '"') {
                            inQuote = false;
                        } else {
                            cell += ch;
                        }
                    } else {
                        if (ch === '"') {
                            inQuote = true;
                        } else if (ch === ',') {
                            row.push(cell.trim());
                            cell = '';
                        } else {
                            cell += ch;
                        }
                    }
                }
                row.push(cell.trim());
                result.push(row);
            }
            return result;
        }

        // ì»¬ëŸ¼ëª…ìœ¼ë¡œ ê²½ë„/ìœ„ë„/ì´ë¦„ í›„ë³´ ìë™ ê°ì§€
        function detectColumns(headers, rows) {
            const lonKeywords = ['ê²½ë„', 'lon', 'longitude', 'lng', 'x', 'long'];
            const latKeywords = ['ìœ„ë„', 'lat', 'latitude', 'y'];
            const nameKeywords = ['ì´ë¦„', 'name', 'ëª…ì¹­', 'ì‹œì„¤ëª…', 'ìƒí˜¸', 'ê±´ë¬¼ëª…', 'ì§€ì ëª…', 'title', 'label'];
            const valueKeywords = ['ê°’', 'value', 'ìˆ˜ëŸ‰', 'ì¸êµ¬', 'ê¸ˆì•¡', 'count', 'amount', 'ê±´ìˆ˜', 'ë©´ì ', 'ë¹„ìœ¨', 'total', 'sum', 'avg', 'í‰ê· ', 'í•©ê³„'];

            let lonIdx = -1, latIdx = -1, nameIdx = -1, valueIdx = -1;
            const lower = headers.map(h => h.toLowerCase());

            for (let i = 0; i < lower.length; i++) {
                for (const kw of lonKeywords) {
                    if (lower[i].includes(kw) && lonIdx === -1) { lonIdx = i; break; }
                }
                for (const kw of latKeywords) {
                    if (lower[i].includes(kw) && latIdx === -1) { latIdx = i; break; }
                }
                for (const kw of nameKeywords) {
                    if (lower[i].includes(kw) && nameIdx === -1) { nameIdx = i; break; }
                }
                for (const kw of valueKeywords) {
                    if (lower[i].includes(kw) && valueIdx === -1) { valueIdx = i; break; }
                }
            }

            // í‚¤ì›Œë“œë¡œ ê°’ ì»¬ëŸ¼ì„ ëª» ì°¾ìœ¼ë©´, 80% ì´ìƒ ìˆ«ìì¸ ì»¬ëŸ¼ ìë™ ê°ì§€ (lon/lat ì œì™¸)
            if (valueIdx === -1 && rows && rows.length > 0) {
                for (let i = 0; i < headers.length; i++) {
                    if (i === lonIdx || i === latIdx) continue;
                    let numCount = 0;
                    const sampleRows = rows.slice(0, Math.min(20, rows.length));
                    for (const row of sampleRows) {
                        if (row[i] !== undefined && row[i] !== '' && !isNaN(Number(row[i]))) numCount++;
                    }
                    if (numCount / sampleRows.length >= 0.8) { valueIdx = i; break; }
                }
            }

            return { lonIdx, latIdx, nameIdx, valueIdx };
        }

        // CSV ì»¬ëŸ¼ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
        function showCsvColumnModal(headers, rows, fileName) {
            return new Promise((resolve) => {
                const modal = document.getElementById('csvModal');
                const colLon = document.getElementById('csvColLon');
                const colLat = document.getElementById('csvColLat');
                const colName = document.getElementById('csvColName');
                const info = document.getElementById('csvModalInfo');
                const previewTable = document.getElementById('csvPreviewTable');

                // ì •ë³´ í‘œì‹œ
                info.textContent = `íŒŒì¼: ${fileName} | ì „ì²´ ${rows.length}ê±´ | ì»¬ëŸ¼ ${headers.length}ê°œ`;

                // ì…€ë ‰íŠ¸ ì˜µì…˜ ìƒì„±
                function fillSelect(select, defaultIdx, allowNone) {
                    select.innerHTML = '';
                    if (allowNone) {
                        const opt = document.createElement('option');
                        opt.value = '-1';
                        opt.textContent = '(ì—†ìŒ)';
                        select.appendChild(opt);
                    }
                    headers.forEach((h, i) => {
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = `[${i}] ${h}`;
                        select.appendChild(opt);
                    });
                    if (defaultIdx >= 0) select.value = defaultIdx;
                }

                const detected = detectColumns(headers);
                fillSelect(colLon, detected.lonIdx, false);
                fillSelect(colLat, detected.latIdx, false);
                fillSelect(colName, detected.nameIdx, true);

                // ë¯¸ë¦¬ë³´ê¸° í…Œì´ë¸”
                function updatePreview() {
                    const li = parseInt(colLon.value);
                    const la = parseInt(colLat.value);
                    const na = parseInt(colName.value);
                    let html = '<tr>';
                    html += `<th>#</th>`;
                    if (na >= 0) html += `<th>${headers[na]}</th>`;
                    html += `<th>${headers[li] || 'ê²½ë„'}</th>`;
                    html += `<th>${headers[la] || 'ìœ„ë„'}</th>`;
                    html += '</tr>';
                    const previewRows = rows.slice(0, 5);
                    previewRows.forEach((row, i) => {
                        html += '<tr>';
                        html += `<td>${i + 1}</td>`;
                        if (na >= 0) html += `<td>${row[na] || ''}</td>`;
                        html += `<td>${row[li] || ''}</td>`;
                        html += `<td>${row[la] || ''}</td>`;
                        html += '</tr>';
                    });
                    previewTable.innerHTML = html;
                }
                updatePreview();
                colLon.onchange = updatePreview;
                colLat.onchange = updatePreview;
                colName.onchange = updatePreview;

                modal.style.display = 'flex';

                function cleanup() {
                    modal.style.display = 'none';
                    document.getElementById('csvModalOk').onclick = null;
                    document.getElementById('csvModalCancel').onclick = null;
                    document.getElementById('csvModalClose').onclick = null;
                }

                document.getElementById('csvModalOk').onclick = () => {
                    cleanup();
                    resolve({
                        lonIdx: parseInt(colLon.value),
                        latIdx: parseInt(colLat.value),
                        nameIdx: parseInt(colName.value)
                    });
                };
                document.getElementById('csvModalCancel').onclick = () => { cleanup(); resolve(null); };
                document.getElementById('csvModalClose').onclick = () => { cleanup(); resolve(null); };
            });
        }

        // CSV íŒŒì¼ ë¡œë“œ ë° Point ë ˆì´ì–´ ìƒì„±
        async function loadCsvLayer(filePath) {
            const csvText = window.electronAPI.readCsvFile(filePath);
            if (!csvText) {
                alert('CSV íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const parsed = parseCSV(csvText);
            if (parsed.length < 2) {
                alert('CSV ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. (í—¤ë” + ìµœì†Œ 1í–‰ í•„ìš”)');
                return;
            }

            const headers = parsed[0];
            const rows = parsed.slice(1);
            const fileName = filePath.split(/[\/\\]/).pop().replace('.csv', '');

            // SQLiteì— ë°ì´í„° ì €ì¥
            if (sqlReady) {
                const sqlTable = importCsvToSqlite(fileName, headers, rows);
                if (sqlTable) {
                    showBottomPanel();
                    document.getElementById('sqlTableSelect').value = sqlTable;
                    runDefaultQuery(sqlTable);
                }
            }

            // ì»¬ëŸ¼ ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
            const selection = await showCsvColumnModal(headers, rows, fileName);
            if (!selection) return; // ì·¨ì†Œ

            const { lonIdx, latIdx, nameIdx } = selection;

            // GeoJSON featuresë¡œ ë³€í™˜
            const features = [];
            let skipped = 0;
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const lon = parseFloat(row[lonIdx]);
                const lat = parseFloat(row[latIdx]);
                if (isNaN(lon) || isNaN(lat)) { skipped++; continue; }
                // ê²½ìœ„ë„ ë²”ìœ„ ì²´í¬
                if (lon < -180 || lon > 180 || lat < -90 || lat > 90) { skipped++; continue; }

                const name = nameIdx >= 0 ? (row[nameIdx] || '') : `Point_${i}`;
                features.push({
                    id: `CSV_POINT_${i}`,
                    geometry: { type: 'Point', coordinates: [lon, lat, 30] },
                    properties: { name: name }
                });
            }

            if (features.length === 0) {
                alert('ìœ íš¨í•œ ì¢Œí‘œê°€ ì—†ìŠµë‹ˆë‹¤.\nê±´ë„ˆë›´ í–‰: ' + skipped);
                return;
            }

            if (skipped > 0) {
                console.log(`CSV ë¡œë“œ ì™„ë£Œ: ${features.length}ê±´ ì„±ê³µ, ${skipped}ê±´ ê±´ë„ˆëœ€`);
            }

            // GeoJSON í˜•íƒœì˜ ë°ì´í„° ê°ì²´ ìƒì„±í•˜ì—¬ ê¸°ì¡´ ë ˆì´ì–´ ìƒì„± ë¡œì§ ì¬ì‚¬ìš©
            const data = { features: features };
            loadGeojsonLayerFromData(fileName, 'Point', data, true);
        }

        // ============ glTF/GLB ì²˜ë¦¬ ============
        function loadGltfLayer(filePath) {
            const fileName = filePath.split(/[\/\\]/).pop().replace(/\.(glb|gltf)$/i, '');
            const fileType = filePath.toLowerCase().endsWith('.glb') ? 'glb' : 'gltf';

            // í˜„ì¬ ì¹´ë©”ë¼ ìœ„ì¹˜ì— ëª¨ë¸ ë°°ì¹˜
            const camera = Module.getViewCamera();
            const cameraPos = camera.getLocation();
            const pos = new Module.JSVector3D(cameraPos.Longitude, cameraPos.Latitude, 0);

            // glTF ë ˆì´ì–´ ìƒì„±
            const layerList = new Module.JSLayerList(true);
            const layer = layerList.createLayer(fileName, Module.ELT_POLYHEDRON);

            const gltfObject = Module.createGLTF(fileName + '_obj_' + index);
            gltfObject.loadFile({
                url: filePath,
                type: fileType,
                position: pos,
                rebuild: true,
            });
            layer.addObject(gltfObject, 0);

            // ë ˆì´ì–´ UI ìƒì„±
            const layerItem = document.createElement('div');
            layerItem.className = 'layer-item';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = true;
            checkbox.addEventListener('change', () => {
                layer.setVisible(checkbox.checked);
            });

            const label = document.createElement('span');
            label.textContent = fileName;
            label.title = fileName;
            label.style.cursor = 'pointer';
            label.addEventListener('click', () => {
                // í´ë¦­ ì‹œ ëª¨ë¸ ìœ„ì¹˜ë¡œ ì´ë™
                camera.move(pos, 89.9, 0, 0);
            });

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
            removeBtn.title = `${fileName} ë ˆì´ì–´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤`;
            removeBtn.addEventListener('click', () => {
                Module.XDEMapRemoveLayer(fileName);
                layerItem.remove();
                mouseOverInterface(false);
            });

            layerItem.appendChild(checkbox);
            layerItem.appendChild(label);
            layerItem.appendChild(removeBtn);

            makeDraggable(layerItem, layer, layerList);
            document.getElementById('interface').appendChild(layerItem);
            index++;

            console.log(`glTF ëª¨ë¸ ë¡œë“œ: ${fileName} (${fileType}) at`, cameraPos);
        }

        // ============ 3DS ì²˜ë¦¬ ============
        let pending3DS = null;

        function start3DSPlacement(filePath) {
            const fileName = filePath.split(/[\/\\]/).pop().replace(/\.3ds$/i, '');
            pending3DS = { filePath, fileName };
            document.getElementById('map').style.cursor = 'crosshair';

            let guide = document.getElementById('placement-guide');
            if (!guide) {
                guide = document.createElement('div');
                guide.id = 'placement-guide';
                guide.style.cssText = 'position:fixed;top:60px;left:50%;transform:translateX(-50%);background:#007acc;color:#fff;padding:8px 20px;border-radius:4px;font-size:13px;z-index:9999;pointer-events:none;';
                document.body.appendChild(guide);
            }
            guide.textContent = 'ë§µì„ í´ë¦­í•˜ë©´ 3DS ëª¨ë¸ì´ ë°°ì¹˜ë©ë‹ˆë‹¤. (ESC: ì·¨ì†Œ)';
            guide.style.display = 'block';
        }

        function cancel3DSPlacement() {
            pending3DS = null;
            document.getElementById('map').style.cursor = '';
            const guide = document.getElementById('placement-guide');
            if (guide) guide.style.display = 'none';
        }

        // ESCë¡œ 3DS ë°°ì¹˜ ì·¨ì†Œ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && pending3DS) cancel3DSPlacement();
        });

        async function load3DSAtPosition(filePath, fileName, position) {
            // ë¡œì»¬ íŒŒì¼ì„ HTTP URLë¡œ ë³€í™˜ (XDWorld ì—”ì§„ì€ HTTP URL í•„ìš”)
            const url = await window.electronAPI.getLocalFileUrl(filePath);
            console.log('3DS ë¡œë“œ ì‹œì‘ - URL:', url);
            console.log('3DS ë°°ì¹˜ ìœ„ì¹˜ - lon:', position.Longitude, 'lat:', position.Latitude, 'alt:', position.Altitude);

            const layerList = new Module.JSLayerList(true);
            const layer = layerList.createLayer(fileName, Module.ELT_POLYHEDRON);

            const polygon = Module.createPolygon(fileName + '_obj_' + index);
            polygon.loadFile({
                position: position,
                url: url,
                align: 'bottom',
                callback: function () {
                    layer.addObject(polygon, 0);
                    console.log(`3DS ëª¨ë¸ ë¡œë“œ ì™„ë£Œ: ${fileName}`);
                }
            });

            // ë ˆì´ì–´ UI ìƒì„±
            const layerItem = document.createElement('div');
            layerItem.className = 'layer-item';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = true;
            checkbox.addEventListener('change', () => {
                layer.setVisible(checkbox.checked);
            });

            const label = document.createElement('span');
            label.textContent = fileName;
            label.title = fileName;
            label.style.cursor = 'pointer';
            label.addEventListener('click', () => {
                const cam = Module.getViewCamera();
                cam.move(position, 80, 0, 0);
            });

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
            removeBtn.title = `${fileName} ë ˆì´ì–´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤`;
            removeBtn.addEventListener('click', () => {
                Module.XDEMapRemoveLayer(fileName);
                layerItem.remove();
                mouseOverInterface(false);
            });

            layerItem.appendChild(checkbox);
            layerItem.appendChild(label);
            layerItem.appendChild(removeBtn);

            makeDraggable(layerItem, layer, layerList);
            document.getElementById('interface').appendChild(layerItem);
            index++;
        }

        function loadGeojsonLayer(filePath) {
            const fileName = filePath.split(/[\/]/).pop().replace('.geojson', '');
            window.electronAPI.readGeoJSON(filePath).then(function (data) {
                if (!data || !data.features || data.features.length === 0) {
                    alert("GeoJSONì— featureê°€ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }
                const type = data.features[0].geometry.type;
                loadGeojsonLayerFromData(fileName, type, data);
            }).catch(err => {
                console.error("GeoJSON íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜:", err);
                console.error("íŒŒì¼ëª…:", fileName);
            });
        }

        function loadGeojsonLayerFromData(fileName, type, data, skipSqlImport = false) {
                // SQLiteì— GeoJSON ë°ì´í„° ì €ì¥ (CSVì—ì„œ í˜¸ì¶œëœ ê²½ìš° skip)
                if (!skipSqlImport && sqlReady && data.features) {
                    const sqlTable = importGeoJsonToSqlite(fileName, data.features);
                    if (sqlTable) {
                        showBottomPanel();
                        document.getElementById('sqlTableSelect').value = sqlTable;
                        runDefaultQuery(sqlTable);
                    }
                }

                const layerList = new Module.JSLayerList(true);
                let layer = null;
                switch (type) {
                    case "Point":
                        layer = layerList.createLayer(fileName, Module.ELT_3DPOINT);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        layer = layerList.createLayer(fileName, Module.ELT_3DLINE);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        layer = layerList.createLayer(fileName, Module.ELT_POLYHEDRON);
                        break;
                    default:
                        alert("ì§€ì›í•˜ì§€ ì•ŠëŠ” geometry type: " + type);
                        return;
                }

                // ë ˆì´ì–´ ê°ì²´ ì„ íƒ í™œì„±í™”
                if (layer && typeof layer.setSelectable === 'function') {
                    layer.setSelectable(true);
                    console.log('ë ˆì´ì–´ ì„ íƒ ì´ë²¤íŠ¸ í™œì„±í™”:', fileName);
                }

                // ëª¨ë“  íƒ€ì…ì— ëœë¤ ìƒ‰ìƒ ì ìš©
                const randomColor = 'rgba(' + Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ', 1.0)';

                // í´ë¦¬ê³¤ìš© ë¼ì¸ ìƒ‰ìƒ (ë” ì–´ë‘ìš´ ìƒ‰ìƒ)
                const strokeColor = 'rgba(' + Math.floor(Math.random() * 200) + ',' +
                    Math.floor(Math.random() * 200) + ',' +
                    Math.floor(Math.random() * 200) + ', 1.0)';

                switch (type) {
                    case "Point":
                        createPointObjects(layer, data.features, 0.0, randomColor);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        createLineObjects(layer, data.features, 0.0, randomColor, 3.0);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        createPolygonObjects(layer, data.features, 0.0, randomColor, strokeColor);
                        break;
                }
                // ìƒˆ ë ˆì´ì–´ UI ìƒì„±
                const layerContainer = document.createElement('div');
                layerContainer.className = 'layer-item-container';

                const layerHeader = document.createElement('div');
                layerHeader.className = 'layer-item-header';

                // ì†ì„± íŒ¨ë„ìš© ì»¨í…Œì´ë„ˆ (ë³„ë„ë¡œ ì €ì¥)
                const propertiesContainer = document.createElement('div');
                propertiesContainer.className = 'layer-item-properties';

                // ì²´í¬ë°•ìŠ¤
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    layer.setVisible(checkbox.checked);
                });

                // geometry íƒ€ì…ì— ë”°ë¥¸ ì•„ì´ì½˜ (ì›ë³¸ ìƒ‰ìƒ ì‚¬ìš©, íˆ¬ëª…ë„ 0ìœ¼ë¡œ ì‹œì‘)
                let iconElement = null;
                if (type === "Point") {
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 0, 0);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '24px';
                    iconElement.style.height = '24px';
                } else if (type === "LineString" || type === "MultiLineString") {
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 1, 0);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '24px';
                    iconElement.style.height = '24px';
                } else if (type === "Polygon" || type === "MultiPolygon") {
                    // í´ë¦¬ê³¤ì€ ë©´ ìƒ‰ìƒ/íˆ¬ëª…ë„ì™€ ì„  ìƒ‰ìƒ/íˆ¬ëª…ë„ë¥¼ ëª¨ë‘ ì „ë‹¬
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 2, 0, strokeColor, 0);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '24px';
                    iconElement.style.height = '24px';
                }

                moveToLayer(layer)

                // ì›ë³¸ ë ˆì´ì–´ ì´ë¦„ ì €ì¥ (ë ˆì´ì–´ ì œê±°ìš©)
                const originalLayerName = fileName;

                // ë ˆì´ì–´ ì´ë¦„
                const label = document.createElement('span');
                label.textContent = fileName;
                label.title = fileName;
                label.style.cursor = 'pointer';

                // í´ë¦­ ì´ë²¤íŠ¸ - ë ˆì´ì–´ë¡œ ì´ë™
                label.addEventListener('click', () => {
                    moveToLayer(layer);
                });

                // x ì œê±° ë²„íŠ¼
                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                removeBtn.title = `${originalLayerName} ë ˆì´ì–´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤`;
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    Module.XDEMapRemoveLayer(originalLayerName);
                    dropSqliteTable(fileName);
                    layerContainer.remove();
                    mouseOverInterface(false);
                });

                // RGBë¥¼ hexë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
                function rgbaToHex(rgba) {
                    const rgb = colorStringToRGB(rgba);
                    return '#' + rgb.map(x => x.toString(16).padStart(2, '0')).join('');
                }

                // hexë¥¼ rgbaë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
                function hexToRgba(hex) {
                    const r = parseInt(hex.substr(1, 2), 16);
                    const g = parseInt(hex.substr(3, 2), 16);
                    const b = parseInt(hex.substr(5, 2), 16);
                    return `rgba(${r}, ${g}, ${b}, 1.0)`;
                }

                // ìƒ‰ìƒ í”¼ì»¤ ë° ì»¨íŠ¸ë¡¤ ë³€ìˆ˜ë“¤
                let pointColorPicker, lineColorPicker, lineWidthInput, fillColorPicker, strokeColorPicker, iconSelect;
                let pointColorCode, lineColorCode, fillColorCode, strokeColorCode;

                // í—¬í¼ í•¨ìˆ˜: ë ˆì´ì–´ ì¬ìƒì„±
                function recreateLayer(layerType, createFunction) {
                    console.log('ë ˆì´ì–´ ì¬ìƒì„±:', originalLayerName);
                    Module.XDEMapRemoveLayer(originalLayerName);
                    const layerList = new Module.JSLayerList(true);
                    layer = layerList.createLayer(originalLayerName, layerType);
                    layer.setVisible(checkbox.checked);
                    createFunction();
                    layer.rebuildObjectLayer();
                }

                // í—¬í¼ í•¨ìˆ˜: ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
                function updateIcon(iconType, color, transparency = 0, strokeColor = null, strokeTransparency = 0) {
                    console.log('ì•„ì´ì½˜ ì—…ë°ì´íŠ¸:', iconType, color);
                    if (iconElement) {
                        const iconUrl = getMarkerIcon(originalLayerName, color, true, iconType, transparency, strokeColor, strokeTransparency);
                        iconElement.src = iconUrl;
                        console.log('ì•„ì´ì½˜ URL ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                    }
                }

                // ì  íƒ€ì… - ì•„ì´ì½˜ ì„ íƒ ë° ìƒ‰ìƒ í”¼ì»¤
                let currentIconType = 'circle';
                let currentPointSize = 10;
                let pointSizeInput;
                if (type === "Point") {
                    // ìƒ‰ìƒ í”¼ì»¤ ìƒì„± (ì›ë³¸ ìƒ‰ìƒ ì‚¬ìš©)
                    pointColorPicker = document.createElement('input');
                    pointColorPicker.type = 'color';
                    pointColorPicker.value = rgbaToHex(randomColor);
                    pointColorPicker.className = 'color-picker';
                    pointColorPicker.title = 'ì  ìƒ‰ìƒ';

                    // ì  ìƒ‰ìƒ hex ì½”ë“œ í‘œì‹œ
                    pointColorCode = document.createElement('span');
                    pointColorCode.className = 'color-code';
                    pointColorCode.textContent = pointColorPicker.value.toUpperCase();

                    // ì•„ì´ì½˜ ì„ íƒ ë“œë¡­ë‹¤ìš´
                    iconSelect = document.createElement('select');
                    iconSelect.className = 'icon-select';
                    iconSelect.title = 'POI ì•„ì´ì½˜ ì„ íƒ';
                    iconSelect.innerHTML = `
                        <option value="circle">â— ì›í˜•</option>
                        <option value="pin">ğŸ“ í•€</option>
                        <option value="star">â­ ë³„</option>
                        <option value="home">ğŸ  ì§‘</option>
                        <option value="flag">ğŸš© ê¹ƒë°œ</option>
                    `;

                    // ì  í¬ê¸° ìŠ¬ë¼ì´ë”
                    pointSizeInput = document.createElement('input');
                    pointSizeInput.type = 'range';
                    pointSizeInput.min = '1';
                    pointSizeInput.max = '50';
                    pointSizeInput.value = currentPointSize;
                    pointSizeInput.className = 'size-slider';
                    pointSizeInput.title = 'ì  í¬ê¸°';

                    // ìƒ‰ìƒ í”¼ì»¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                    pointColorPicker.addEventListener('change', (e) => {
                        const newColor = hexToRgba(e.target.value);
                        pointColorCode.textContent = e.target.value.toUpperCase();

                        recreateLayer(Module.ELT_3DPOINT, () => {
                            if (currentIconType === 'circle') {
                                createPointObjects(layer, data.features, 0.0, newColor, null, currentPointSize);
                            } else {
                                const iconUrl = createColoredIconUrl(currentIconType, e.target.value);
                                createPointObjects(layer, data.features, 0.0, newColor, iconUrl, currentPointSize);
                            }
                        });

                        // ë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ ì•„ì´ì½˜ë„ ì—…ë°ì´íŠ¸
                        if (iconElement) {
                            iconElement.src = currentIconType === 'circle'
                                ? getMarkerIcon(fileName, newColor, true, 0)
                                : createColoredIconUrl(currentIconType, e.target.value);
                        }
                    });

                    // ì•„ì´ì½˜ ì„ íƒ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                    iconSelect.addEventListener('change', (e) => {
                        currentIconType = e.target.value;
                        console.log('ì•„ì´ì½˜ íƒ€ì… ë³€ê²½:', currentIconType);

                        const currentColor = hexToRgba(pointColorPicker.value);

                        recreateLayer(Module.ELT_3DPOINT, () => {
                            if (currentIconType === 'circle') {
                                console.log('ê¸°ë³¸ ì›í˜• ì•„ì´ì½˜ ì‚¬ìš©');
                                createPointObjects(layer, data.features, 0.0, currentColor, null, currentPointSize);
                            } else {
                                const iconUrl = createColoredIconUrl(currentIconType, pointColorPicker.value);
                                console.log('SVG ì•„ì´ì½˜ URL:', iconUrl);
                                createPointObjects(layer, data.features, 0.0, currentColor, iconUrl, currentPointSize);
                            }
                        });

                        // ë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ ì•„ì´ì½˜ë„ ì—…ë°ì´íŠ¸
                        if (iconElement) {
                            iconElement.src = currentIconType === 'circle'
                                ? getMarkerIcon(fileName, currentColor, true, 0)
                                : createColoredIconUrl(currentIconType, pointColorPicker.value);
                        }
                    });

                    // ì  í¬ê¸° ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                    pointSizeInput.addEventListener('input', (e) => {
                        currentPointSize = parseFloat(e.target.value) || 10;
                        console.log('ì  í¬ê¸° ë³€ê²½:', currentPointSize);

                        const currentColor = hexToRgba(pointColorPicker.value);

                        recreateLayer(Module.ELT_3DPOINT, () => {
                            if (currentIconType === 'circle') {
                                createPointObjects(layer, data.features, 0.0, currentColor, null, currentPointSize);
                            } else {
                                const iconUrl = createColoredIconUrl(currentIconType, pointColorPicker.value);
                                createPointObjects(layer, data.features, 0.0, currentColor, iconUrl, currentPointSize);
                            }
                        });
                    });
                }

                // ë¼ì¸ íƒ€ì… ìƒ‰ìƒ í”¼ì»¤ ë° ë‘ê»˜ ì»¨íŠ¸ë¡¤
                let currentLineWidth = 3.0;
                let currentLineTransparency = 0;
                let lineTransparencyInput;
                if (type === "LineString" || type === "MultiLineString") {
                    lineColorPicker = document.createElement('input');
                    lineColorPicker.type = 'color';
                    lineColorPicker.value = rgbaToHex(randomColor);
                    lineColorPicker.className = 'color-picker';
                    lineColorPicker.title = 'ì„  ìƒ‰ìƒ';

                    // ë¼ì¸ ìƒ‰ìƒ hex ì½”ë“œ í‘œì‹œ
                    lineColorCode = document.createElement('span');
                    lineColorCode.className = 'color-code';
                    lineColorCode.textContent = lineColorPicker.value.toUpperCase();

                    lineColorPicker.addEventListener('change', (e) => {
                        const newColor = hexToRgba(e.target.value);
                        lineColorCode.textContent = e.target.value.toUpperCase();

                        recreateLayer(Module.ELT_3DLINE, () => {
                            createLineObjects(layer, data.features, 0.0, newColor, currentLineWidth, currentLineTransparency);
                        });

                        updateIcon(1, newColor, currentLineTransparency);
                    });

                    // ì„  ë‘ê»˜ ì…ë ¥ (1-20 ë²”ìœ„)
                    lineWidthInput = document.createElement('input');
                    lineWidthInput.type = 'number';
                    lineWidthInput.min = '1';
                    lineWidthInput.max = '20';
                    lineWidthInput.step = '0.5';
                    lineWidthInput.value = currentLineWidth;
                    lineWidthInput.style.width = '50px';
                    lineWidthInput.style.backgroundColor = '#3c3c3c';
                    lineWidthInput.style.color = '#cccccc';
                    lineWidthInput.style.border = '1px solid #555';
                    lineWidthInput.style.borderRadius = '3px';
                    lineWidthInput.style.padding = '2px 4px';
                    lineWidthInput.style.fontSize = '11px';
                    lineWidthInput.title = 'ì„  ë‘ê»˜';
                    lineWidthInput.addEventListener('change', (e) => {
                        currentLineWidth = parseFloat(e.target.value) || 3.0;

                        recreateLayer(Module.ELT_3DLINE, () => {
                            createLineObjects(layer, data.features, 0.0, hexToRgba(lineColorPicker.value), currentLineWidth, currentLineTransparency);
                        });
                    });

                    // íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë” (0-100% ë²”ìœ„)
                    lineTransparencyInput = document.createElement('input');
                    lineTransparencyInput.type = 'range';
                    lineTransparencyInput.min = '0';
                    lineTransparencyInput.max = '100';
                    lineTransparencyInput.step = '1';
                    lineTransparencyInput.value = currentLineTransparency;
                    lineTransparencyInput.style.width = '100px';
                    lineTransparencyInput.title = 'íˆ¬ëª…ë„: ' + currentLineTransparency + '%';
                    lineTransparencyInput.addEventListener('input', (e) => {
                        currentLineTransparency = parseInt(e.target.value);
                        e.target.title = 'íˆ¬ëª…ë„: ' + currentLineTransparency + '%';

                        const currentColor = hexToRgba(lineColorPicker.value);

                        recreateLayer(Module.ELT_3DLINE, () => {
                            createLineObjects(layer, data.features, 0.0, currentColor, currentLineWidth, currentLineTransparency);
                        });

                        updateIcon(1, currentColor, currentLineTransparency);
                    });
                }

                // í´ë¦¬ê³¤ íƒ€ì… ìƒ‰ìƒ í”¼ì»¤
                let currentFillTransparency = 0;
                let currentStrokeTransparency = 0;
                let fillTransparencyInput, strokeTransparencyInput;
                if (type === "Polygon" || type === "MultiPolygon") {
                    // ë©´ ìƒ‰ìƒ í”¼ì»¤ (ì›ë³¸ ìƒ‰ìƒ ì‚¬ìš©)
                    console.log('í´ë¦¬ê³¤ ìƒ‰ìƒ ì´ˆê¸°í™” - randomColor:', randomColor);
                    console.log('í´ë¦¬ê³¤ ìƒ‰ìƒ ì´ˆê¸°í™” - strokeColor:', strokeColor);

                    fillColorPicker = document.createElement('input');
                    fillColorPicker.type = 'color';
                    const fillHex = rgbaToHex(randomColor);
                    console.log('ë©´ ìƒ‰ìƒ hex:', fillHex);
                    fillColorPicker.value = fillHex;
                    fillColorPicker.className = 'color-picker';
                    fillColorPicker.title = 'ë©´ ìƒ‰ìƒ';

                    // ë©´ ìƒ‰ìƒ hex ì½”ë“œ í‘œì‹œ
                    fillColorCode = document.createElement('span');
                    fillColorCode.className = 'color-code';
                    fillColorCode.textContent = fillColorPicker.value.toUpperCase();

                    fillColorPicker.addEventListener('change', (e) => {
                        console.log('ë©´ ìƒ‰ìƒ ë³€ê²½:', e.target.value);
                        const newFillColor = hexToRgba(e.target.value);
                        const currentStrokeColor = strokeColorPicker ? hexToRgba(strokeColorPicker.value) : strokeColor;
                        fillColorCode.textContent = e.target.value.toUpperCase();
                        console.log('newFillColor:', newFillColor, 'currentStrokeColor:', currentStrokeColor);

                        recreateLayer(Module.ELT_POLYHEDRON, () => {
                            createPolygonObjects(layer, data.features, 0.0, newFillColor, currentStrokeColor, currentFillTransparency, currentStrokeTransparency);
                        });

                        updateIcon(2, newFillColor, currentFillTransparency, currentStrokeColor, currentStrokeTransparency);
                    });

                    // ë©´ íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë” (0-100% ë²”ìœ„)
                    fillTransparencyInput = document.createElement('input');
                    fillTransparencyInput.type = 'range';
                    fillTransparencyInput.min = '0';
                    fillTransparencyInput.max = '100';
                    fillTransparencyInput.step = '1';
                    fillTransparencyInput.value = currentFillTransparency;
                    fillTransparencyInput.style.width = '100px';
                    fillTransparencyInput.title = 'ë©´ íˆ¬ëª…ë„: ' + currentFillTransparency + '%';
                    fillTransparencyInput.addEventListener('input', (e) => {
                        currentFillTransparency = parseInt(e.target.value);
                        e.target.title = 'ë©´ íˆ¬ëª…ë„: ' + currentFillTransparency + '%';

                        const currentFillColor = fillColorPicker ? hexToRgba(fillColorPicker.value) : randomColor;
                        const currentStrokeColor = strokeColorPicker ? hexToRgba(strokeColorPicker.value) : strokeColor;

                        recreateLayer(Module.ELT_POLYHEDRON, () => {
                            createPolygonObjects(layer, data.features, 0.0, currentFillColor, currentStrokeColor, currentFillTransparency, currentStrokeTransparency);
                        });

                        updateIcon(2, currentFillColor, currentFillTransparency, currentStrokeColor, currentStrokeTransparency);
                    });

                    // ì„  ìƒ‰ìƒ í”¼ì»¤ (ì›ë³¸ ìƒ‰ìƒ ì‚¬ìš©)
                    strokeColorPicker = document.createElement('input');
                    strokeColorPicker.type = 'color';
                    const strokeHex = rgbaToHex(strokeColor);
                    console.log('ì„  ìƒ‰ìƒ hex:', strokeHex);
                    strokeColorPicker.value = strokeHex;
                    strokeColorPicker.className = 'color-picker';
                    strokeColorPicker.title = 'ì„  ìƒ‰ìƒ';

                    // ì„  ìƒ‰ìƒ hex ì½”ë“œ í‘œì‹œ
                    strokeColorCode = document.createElement('span');
                    strokeColorCode.className = 'color-code';
                    strokeColorCode.textContent = strokeColorPicker.value.toUpperCase();

                    strokeColorPicker.addEventListener('change', (e) => {
                        console.log('ì„  ìƒ‰ìƒ ë³€ê²½:', e.target.value);
                        const newStrokeColor = hexToRgba(e.target.value);
                        const currentFillColor = fillColorPicker ? hexToRgba(fillColorPicker.value) : randomColor;
                        strokeColorCode.textContent = e.target.value.toUpperCase();
                        console.log('currentFillColor:', currentFillColor, 'newStrokeColor:', newStrokeColor);

                        recreateLayer(Module.ELT_POLYHEDRON, () => {
                            createPolygonObjects(layer, data.features, 0.0, currentFillColor, newStrokeColor, currentFillTransparency, currentStrokeTransparency);
                        });

                        updateIcon(2, currentFillColor, currentFillTransparency, newStrokeColor, currentStrokeTransparency);
                    });

                    // ì„  íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë” (0-100% ë²”ìœ„)
                    strokeTransparencyInput = document.createElement('input');
                    strokeTransparencyInput.type = 'range';
                    strokeTransparencyInput.min = '0';
                    strokeTransparencyInput.max = '100';
                    strokeTransparencyInput.step = '1';
                    strokeTransparencyInput.value = currentStrokeTransparency;
                    strokeTransparencyInput.style.width = '100px';
                    strokeTransparencyInput.title = 'ì„  íˆ¬ëª…ë„: ' + currentStrokeTransparency + '%';
                    strokeTransparencyInput.addEventListener('input', (e) => {
                        currentStrokeTransparency = parseInt(e.target.value);
                        e.target.title = 'ì„  íˆ¬ëª…ë„: ' + currentStrokeTransparency + '%';

                        const currentFillColor = fillColorPicker ? hexToRgba(fillColorPicker.value) : randomColor;
                        const currentStrokeColor = strokeColorPicker ? hexToRgba(strokeColorPicker.value) : strokeColor;

                        recreateLayer(Module.ELT_POLYHEDRON, () => {
                            createPolygonObjects(layer, data.features, 0.0, currentFillColor, currentStrokeColor, currentFillTransparency, currentStrokeTransparency);
                        });

                        updateIcon(2, currentFillColor, currentFillTransparency, currentStrokeColor, currentStrokeTransparency);
                    });
                }

                // í™•ì¥ ì•„ì´ì½˜ ìƒì„±
                // ì¡°ë¦½ - í—¤ë” ë¶€ë¶„ (ê¸°ë³¸ ì •ë³´)
                layerHeader.appendChild(checkbox);
                if (iconElement) {
                    layerHeader.appendChild(iconElement);
                }
                layerHeader.appendChild(label);
                layerHeader.appendChild(removeBtn);


                // ì†ì„± íŒ¨ë„ í—¤ë” (ë‹«ê¸° ë²„íŠ¼ í¬í•¨)
                const propertiesHeader = document.createElement('div');
                propertiesHeader.className = 'properties-header';
                const propertiesTitle = document.createElement('span');
                propertiesTitle.textContent = 'ì†ì„±';
                const closePropertiesBtn = document.createElement('button');
                closePropertiesBtn.className = 'close-properties-btn';
                closePropertiesBtn.textContent = 'Ã—';
                closePropertiesBtn.title = 'ë‹«ê¸°';
                closePropertiesBtn.addEventListener('click', () => {
                    propertiesContainer.style.display = 'none';
                });
                propertiesHeader.appendChild(propertiesTitle);
                propertiesHeader.appendChild(closePropertiesBtn);
                propertiesContainer.appendChild(propertiesHeader);

                // íƒ€ì…ë³„ ì†ì„± ì»¨íŠ¸ë¡¤ ì¶”ê°€ (ì†ì„± íŒ¨ë„ìš©)
                if (type === "Point") {
                    // ì  ìƒ‰ìƒ
                    const colorRow = document.createElement('div');
                    colorRow.className = 'property-row';
                    const colorLabel = document.createElement('span');
                    colorLabel.className = 'property-label';
                    colorLabel.textContent = 'ì  ìƒ‰ìƒ';
                    colorRow.appendChild(colorLabel);
                    colorRow.appendChild(pointColorPicker);
                    colorRow.appendChild(pointColorCode);
                    propertiesContainer.appendChild(colorRow);

                    // ì  í¬ê¸°
                    if (pointSizeInput) {
                        const sizeRow = document.createElement('div');
                        sizeRow.className = 'property-row';
                        const sizeLabel = document.createElement('span');
                        sizeLabel.className = 'property-label';
                        sizeLabel.textContent = 'ì  í¬ê¸°';
                        sizeRow.appendChild(sizeLabel);
                        sizeRow.appendChild(pointSizeInput);
                        propertiesContainer.appendChild(sizeRow);
                    }

                    // ì•„ì´ì½˜ ì¢…ë¥˜
                    if (iconSelect) {
                        const iconRow = document.createElement('div');
                        iconRow.className = 'property-row';
                        const iconLabel = document.createElement('span');
                        iconLabel.className = 'property-label';
                        iconLabel.textContent = 'ì•„ì´ì½˜ ì¢…ë¥˜';
                        iconRow.appendChild(iconLabel);
                        iconRow.appendChild(iconSelect);
                        propertiesContainer.appendChild(iconRow);
                    }
                } else if (type === "LineString" || type === "MultiLineString") {
                    // ì„  ìƒ‰ìƒ
                    const colorRow = document.createElement('div');
                    colorRow.className = 'property-row';
                    const colorLabel = document.createElement('span');
                    colorLabel.className = 'property-label';
                    colorLabel.textContent = 'ì„  ìƒ‰ìƒ';
                    colorRow.appendChild(colorLabel);
                    colorRow.appendChild(lineColorPicker);
                    colorRow.appendChild(lineColorCode);
                    propertiesContainer.appendChild(colorRow);

                    // ì„  ë‘ê»˜
                    if (lineWidthInput) {
                        const widthRow = document.createElement('div');
                        widthRow.className = 'property-row';
                        const widthLabel = document.createElement('span');
                        widthLabel.className = 'property-label';
                        widthLabel.textContent = 'ì„  ë‘ê»˜';
                        widthRow.appendChild(widthLabel);
                        widthRow.appendChild(lineWidthInput);
                        propertiesContainer.appendChild(widthRow);
                    }

                    // ì„  íˆ¬ëª…ë„
                    if (lineTransparencyInput) {
                        const transparencyRow = document.createElement('div');
                        transparencyRow.className = 'property-row';
                        const transparencyLabel = document.createElement('span');
                        transparencyLabel.className = 'property-label';
                        transparencyLabel.textContent = 'ì„  íˆ¬ëª…ë„';
                        transparencyRow.appendChild(transparencyLabel);
                        transparencyRow.appendChild(lineTransparencyInput);
                        propertiesContainer.appendChild(transparencyRow);
                    }
                } else if (type === "Polygon" || type === "MultiPolygon") {
                    const fillRow = document.createElement('div');
                    fillRow.className = 'property-row';
                    const fillLabel = document.createElement('span');
                    fillLabel.className = 'property-label';
                    fillLabel.textContent = 'ë©´ ìƒ‰ìƒ';
                    fillRow.appendChild(fillLabel);
                    fillRow.appendChild(fillColorPicker);
                    fillRow.appendChild(fillColorCode);
                    propertiesContainer.appendChild(fillRow);

                    if (fillTransparencyInput) {
                        const fillTransparencyRow = document.createElement('div');
                        fillTransparencyRow.className = 'property-row';
                        const fillTransparencyLabel = document.createElement('span');
                        fillTransparencyLabel.className = 'property-label';
                        fillTransparencyLabel.textContent = 'ë©´ íˆ¬ëª…ë„';
                        fillTransparencyRow.appendChild(fillTransparencyLabel);
                        fillTransparencyRow.appendChild(fillTransparencyInput);
                        propertiesContainer.appendChild(fillTransparencyRow);
                    }

                    // ì„  ìƒ‰ìƒ
                    const strokeRow = document.createElement('div');
                    strokeRow.className = 'property-row';
                    const strokeLabel = document.createElement('span');
                    strokeLabel.className = 'property-label';
                    strokeLabel.textContent = 'ì„  ìƒ‰ìƒ';
                    strokeRow.appendChild(strokeLabel);
                    strokeRow.appendChild(strokeColorPicker);
                    strokeRow.appendChild(strokeColorCode);
                    propertiesContainer.appendChild(strokeRow);

                    // ì„  ë‘ê»˜ (ì¶”í›„ êµ¬í˜„ ê°€ëŠ¥)
                    // TODO: ì„  ë‘ê»˜ ìŠ¬ë¼ì´ë” ì¶”ê°€

                    // ì„  íˆ¬ëª…ë„
                    if (strokeTransparencyInput) {
                        const strokeTransparencyRow = document.createElement('div');
                        strokeTransparencyRow.className = 'property-row';
                        const strokeTransparencyLabel = document.createElement('span');
                        strokeTransparencyLabel.className = 'property-label';
                        strokeTransparencyLabel.textContent = 'ì„  íˆ¬ëª…ë„';
                        strokeTransparencyRow.appendChild(strokeTransparencyLabel);
                        strokeTransparencyRow.appendChild(strokeTransparencyInput);
                        propertiesContainer.appendChild(strokeTransparencyRow);
                    }
                }

                // ë ˆì´ì–´ ì‚­ì œ ë²„íŠ¼ (ëª¨ë“  íƒ€ì… ê³µí†µ)
                const deleteRow = document.createElement('div');
                deleteRow.className = 'property-row';
                deleteRow.style.marginTop = '12px';
                deleteRow.style.paddingTop = '12px';
                deleteRow.style.borderTop = '1px solid #3c3c3c';

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'ë ˆì´ì–´ ì‚­ì œ';
                deleteButton.style.width = '100%';
                deleteButton.style.backgroundColor = '#e74c3c';
                deleteButton.style.color = '#ffffff';
                deleteButton.style.border = 'none';
                deleteButton.style.borderRadius = '3px';
                deleteButton.style.padding = '6px 12px';
                deleteButton.style.fontSize = '12px';
                deleteButton.style.cursor = 'pointer';
                deleteButton.style.transition = 'background-color 0.2s';

                deleteButton.addEventListener('mouseenter', () => {
                    deleteButton.style.backgroundColor = '#c0392b';
                });
                deleteButton.addEventListener('mouseleave', () => {
                    deleteButton.style.backgroundColor = '#e74c3c';
                });
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`"${fileName}" ë ˆì´ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        Module.XDEMapRemoveLayer(originalLayerName);
                        dropSqliteTable(fileName);
                        layerContainer.remove();
                        mouseOverInterface(false);
                    }
                });

                deleteRow.appendChild(deleteButton);
                propertiesContainer.appendChild(deleteRow);

                // ì†ì„± íŒ¨ë„ ì´ˆê¸° ìƒíƒœëŠ” ìˆ¨ê¹€
                propertiesContainer.style.display = 'none';
                propertiesContainer.style.paddingLeft = '30px';
                propertiesContainer.style.paddingRight = '6px';
                propertiesContainer.style.paddingTop = '6px';
                propertiesContainer.style.paddingBottom = '6px';

                // ì»¨í…Œì´ë„ˆ ì¡°ë¦½
                layerContainer.appendChild(layerHeader);
                layerContainer.appendChild(propertiesContainer);

                // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì¶”ê°€
                layerContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // íƒ€ì…ë³„ í˜„ì¬ ìƒ‰ìƒ ì •ë³´ë¥¼ style ê°ì²´ì— í¬í•¨
                    // ìƒ‰ìƒ í”¼ì»¤ê°€ ìˆìœ¼ë©´ í”¼ì»¤ ê°’ ì‚¬ìš©, ì—†ìœ¼ë©´ ì´ˆê¸° ìƒ‰ìƒ ì‚¬ìš©
                    const style = {};
                    switch (type) {
                        case "Point":
                            style.pointColor = pointColorPicker ? pointColorPicker.value : rgbaToHex(randomColor);
                            style.iconType = currentIconType || 'circle';
                            style.pointSize = currentPointSize || 10;
                            break;
                        case "LineString":
                        case "MultiLineString":
                            style.lineColor = lineColorPicker ? lineColorPicker.value : rgbaToHex(randomColor);
                            style.lineWidth = currentLineWidth || 3.0;
                            break;
                        case "Polygon":
                        case "MultiPolygon":
                            style.fillColor = fillColorPicker ? fillColorPicker.value : rgbaToHex(randomColor);
                            style.lineColor = strokeColorPicker ? strokeColorPicker.value : rgbaToHex(strokeColor);
                            style.fillOpacity = currentFillTransparency;
                            style.strokeOpacity = currentStrokeTransparency;
                            break;
                    }

                    // updateStyle í•¨ìˆ˜ ì •ì˜ - ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ì—ì„œ ìƒ‰ìƒ ë³€ê²½ ì‹œ í˜¸ì¶œ
                    const updateStyle = () => {
                        console.log('ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ì—ì„œ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸:', type);

                        switch (type) {
                            case "Point":
                                const newPointColor = hexToRgba(style.pointColor);
                                const newIconType = style.iconType || 'circle';
                                const newPointSize = parseFloat(style.pointSize) || currentPointSize;
                                console.log('ìƒˆ í¬ì¸íŠ¸ ìƒ‰ìƒ:', newPointColor, 'ì•„ì´ì½˜ íƒ€ì…:', newIconType, 'ì  í¬ê¸°:', newPointSize);

                                // currentIconType, currentPointSize ì—…ë°ì´íŠ¸
                                currentIconType = newIconType;
                                currentPointSize = newPointSize;

                                recreateLayer(Module.ELT_3DPOINT, () => {
                                    if (newIconType === 'circle') {
                                        createPointObjects(layer, data.features, 0.0, newPointColor, null, currentPointSize);
                                    } else {
                                        const iconUrl = createColoredIconUrl(newIconType, style.pointColor);
                                        createPointObjects(layer, data.features, 0.0, newPointColor, iconUrl, currentPointSize);
                                    }
                                });

                                // ë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
                                if (iconElement) {
                                    iconElement.src = newIconType === 'circle'
                                        ? getMarkerIcon(fileName, newPointColor, true, 0)
                                        : createColoredIconUrl(newIconType, style.pointColor);
                                }

                                // í™•ì¥ ë©”ë‰´ ìƒ‰ìƒ í”¼ì»¤ì™€ ì•„ì´ì½˜ ì…€ë ‰íŠ¸, ì  í¬ê¸° ë™ê¸°í™”
                                if (pointColorPicker) {
                                    pointColorPicker.value = style.pointColor;
                                    if (pointColorCode) {
                                        pointColorCode.textContent = style.pointColor.toUpperCase();
                                    }
                                }
                                if (iconSelect) {
                                    iconSelect.value = newIconType;
                                }
                                if (pointSizeInput) {
                                    pointSizeInput.value = currentPointSize;
                                }
                                break;

                            case "LineString":
                            case "MultiLineString":
                                const newLineColor = hexToRgba(style.lineColor);
                                const newLineWidth = parseFloat(style.lineWidth) || currentLineWidth;
                                console.log('ìƒˆ ë¼ì¸ ìƒ‰ìƒ:', newLineColor, 'ì„  ë‘ê»˜:', newLineWidth);

                                // currentLineWidth ì—…ë°ì´íŠ¸
                                currentLineWidth = newLineWidth;

                                recreateLayer(Module.ELT_3DLINE, () => {
                                    createLineObjects(layer, data.features, 0.0, newLineColor, currentLineWidth, currentLineTransparency);
                                });
                                updateIcon(1, newLineColor, currentLineTransparency);

                                // í™•ì¥ ë©”ë‰´ ìƒ‰ìƒ í”¼ì»¤ ë° ë‘ê»˜ ë™ê¸°í™”
                                if (lineColorPicker) {
                                    lineColorPicker.value = style.lineColor;
                                }
                                if (lineWidthInput) {
                                    lineWidthInput.value = currentLineWidth;
                                }
                                break;

                            case "Polygon":
                            case "MultiPolygon":
                                const newFillColor = hexToRgba(style.fillColor);
                                const newStrokeColor = hexToRgba(style.lineColor);
                                const newFillOpacity = parseFloat(style.fillOpacity) || 0;
                                const newStrokeOpacity = parseFloat(style.strokeOpacity) || 0;
                                console.log('ìƒˆ ë©´ ìƒ‰ìƒ:', newFillColor, 'ë©´ íˆ¬ëª…ë„:', newFillOpacity);
                                console.log('ìƒˆ ì„  ìƒ‰ìƒ:', newStrokeColor, 'ì„  íˆ¬ëª…ë„:', newStrokeOpacity);

                                // íˆ¬ëª…ë„ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
                                currentFillTransparency = newFillOpacity;
                                currentStrokeTransparency = newStrokeOpacity;

                                recreateLayer(Module.ELT_POLYHEDRON, () => {
                                    createPolygonObjects(layer, data.features, 0.0, newFillColor, newStrokeColor, newFillOpacity, newStrokeOpacity);
                                });
                                updateIcon(2, newFillColor, newFillOpacity, newStrokeColor, newStrokeOpacity);

                                // í™•ì¥ ë©”ë‰´ ìƒ‰ìƒ í”¼ì»¤ ë° íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë”ë„ ë™ê¸°í™”
                                if (fillColorPicker) {
                                    fillColorPicker.value = style.fillColor;
                                }
                                if (strokeColorPicker) {
                                    strokeColorPicker.value = style.lineColor;
                                }
                                if (fillTransparencyInput) {
                                    fillTransparencyInput.value = newFillOpacity;
                                }
                                if (strokeTransparencyInput) {
                                    strokeTransparencyInput.value = newStrokeOpacity;
                                }
                                break;
                        }
                    };

                    const layerData = {
                        layerItem: layerContainer,
                        layer: layer,
                        label: label,
                        removeBtn: removeBtn,
                        propertiesContent: propertiesContainer,
                        originalLayerName: originalLayerName,
                        fileName: fileName,
                        style: style,
                        updateStyle: updateStyle
                    };

                    // ë©”ë‰´ ë™ì  ìƒì„±
                    buildContextMenu(layerData);

                    // ë©”ë‰´ í‘œì‹œ (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ìë™ ì¡°ì •)
                    showContextMenu(e, layerContainer);
                });

                // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                makeDraggable(layerContainer, layer, layerList);

                document.getElementById('interface').appendChild(layerContainer);
                index++;
        }
        function moveToLayer(layer) {
            try {
                let obj = layer.indexAtObject(0);
                if (!obj || !obj.position) {
                    console.warn('ë ˆì´ì–´ì— ê°ì²´ê°€ ì—†ê±°ë‚˜ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                console.log('ë ˆì´ì–´ë¡œ ì´ë™:', obj.position.longitude, obj.position.latitude, obj.position.altitude);
                let cenLon = obj.position.longitude;
                let cenLat = obj.position.latitude;
                let cenAlt = obj.position.altitude;
                Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, cenAlt + 1000), 89.9, 0, 0);
            } catch (e) {
                console.error('ë ˆì´ì–´ ì´ë™ ì˜¤ë¥˜:', e.message);
            }
        }
        // ECEF -> Geodetic (lat, lon, h), WGS84
        function ecefToLla(x, y, z) {
            const a = 6378137.0;                 // WGS84 semi-major
            const f = 1 / 298.257223563;         // flattening
            const e2 = f * (2 - f);              // first eccentricity^2

            const lon = Math.atan2(y, x);
            const p = Math.hypot(x, y);
            let lat = Math.atan2(z, p * (1 - e2));
            let N, h, latNew;

            for (let i = 0; i < 10; i++) {
                const sinLat = Math.sin(lat);
                N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                h = p / Math.cos(lat) - N;
                latNew = Math.atan2(z, p * (1 - e2 * N / (N + h)));
                if (Math.abs(lat - latNew) < 1e-12) { lat = latNew; break; }
                lat = latNew;
            }
            N = a / Math.sqrt(1 - e2 * Math.sin(lat) ** 2);
            h = p / Math.cos(lat) - N;

            return {
                latDeg: lat * 180 / Math.PI,
                lonDeg: lon * 180 / Math.PI,
                h
            };
        }
        function loadMetaLayer(filePath) {
            window.electronAPI.readMeta(filePath)
                .then(data => {
                    try {

                        const jsonData = JSON.parse(data);
                        const layerName = jsonData['name'];
                        const layerPath = jsonData['path'];
                        const layerType = jsonData['type'];
                        const minLon = jsonData['area']['min']['lon'];
                        const maxLon = jsonData['area']['max']['lon'];
                        const minLat = jsonData['area']['min']['lat'];
                        const maxLat = jsonData['area']['max']['lat'];
                        const minLv = jsonData['level']['min'];
                        const maxLv = jsonData['level']['max'];
                        let cenLon = (minLon + maxLon) / 2;
                        let cenLat = (minLat + maxLat) / 2;
                        let alt = 1000;
                        let layer = null;
                        let layerList = new Module.JSLayerList(false);
                        let type = null;
                        if (layerType == "ETLT_PNG_IMAGE") {
                            type = Module.TILE_LAYER_TYPE_IMAGE;
                            alt = 5000;
                        }
                        if (layerType == "ETLT_VECTOR_PIPE") {
                            type = Module.TILE_LAYER_TYPE_VECTOR_PIPE;
                            alt = 500;
                        }
                        if (layerType == "ETLT_REAL3D") {
                            type = Module.TILE_LAYER_TYPE_REAL3D;
                        }
                        if (layerType == "ETLT_3DPOINT") {
                            type = Module.TILE_LAYER_TYPE_POI;
                            // ì•„ë˜ ì¢Œí‘œëŠ” í…ŒìŠ¤íŠ¸ìš©ì…ë‹ˆë‹¤. ì œì£¼ë„ 
                            cenLon = 126.852;
                            cenLat = 33.523;
                            alt = 500;
                        }
                        Module.XDEMapCreateLayer(layerName, layerPath, 0, true, true, true, type, minLv, maxLv);
                        Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, alt), 89.9, 0, 0);
                        layer = layerList.nameAtLayer(layerName);

                        if (layer != null) {

                            const layerItem = document.createElement('div');
                            layerItem.className = 'layer-item';

                            // ì²´í¬ë°•ìŠ¤
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', () => {
                                layer.setVisible(checkbox.checked);
                            });

                            // ë ˆì´ì–´ ì´ë¦„
                            const label = document.createElement('span');
                            label.textContent = layerName;
                            label.title = layerName; // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ì „ì²´ ì´ë¦„ í‘œì‹œ
                            label.style.cursor = 'pointer'; // í´ë¦­ ê°€ëŠ¥í•¨ì„ í‘œì‹œ
                            label.addEventListener('click', () => {
                                // ë ˆì´ì–´ í´ë¦­ì‹œ ë™ì‘
                                Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, 5000), 89.9, 0, 0);
                            });

                            // x ì œê±° ë²„íŠ¼
                            const removeBtn = document.createElement('button');
                            removeBtn.innerHTML = '<svg width="10" height="10" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                            removeBtn.title = `${label.textContent} ë ˆì´ì–´ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤`;
                            removeBtn.addEventListener('click', () => {
                                Module.XDEMapRemoveLayer(label.textContent);
                                layerItem.remove();
                                mouseOverInterface(false);
                                if (layerType == "ETLT_VECTOR_PIPE") {
                                    Module.XDESetPlanetTransparecny(0.0);
                                }
                            });

                            // ì¡°ë¦½
                            layerItem.appendChild(checkbox);
                            layerItem.appendChild(label);

                            if (layerType == "ETLT_VECTOR_PIPE") {
                                const transparencyBtn = document.createElement('button');
                                transparencyBtn.textContent = 'T';
                                let isTransparent = false;
                                transparencyBtn.addEventListener('click', () => {
                                    isTransparent = !isTransparent;
                                    Module.XDESetPlanetTransparecny(isTransparent ? 0.25 : 1.0);
                                });
                                layerItem.appendChild(transparencyBtn);
                            }

                            layerItem.appendChild(removeBtn);

                            // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì¶”ê°€
                            layerItem.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();

                                window.currentContextLayer = {
                                    layerItem: layerItem,
                                    layer: layer,
                                    label: label,
                                    removeBtn: removeBtn
                                };

                                showContextMenu(e, layerItem);
                            });

                            // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
                            makeDraggable(layerItem, layer, layerList);

                            document.getElementById('interface').appendChild(layerItem);
                            index++;
                        }
                    } catch (e) {
                        console.error("Failed to parse .meta file as JSON:", e);
                        alert(".meta íŒŒì¼ì„ JSONìœ¼ë¡œ íŒŒì‹±í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                    }
                })
                .catch(err => {
                    console.error("Failed to read .meta file:", err);
                    alert(".meta íŒŒì¼ì„ ì½ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                });
        }



    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.11.0/sql-wasm.js"></script>
</body>

</html>