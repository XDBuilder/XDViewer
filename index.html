<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDViewer</title>
    <link rel="stylesheet" href="style.css"> <!-- 외부 CSS 파일 연결 -->
</head>

<body>
    <!-- 지도 표시 영역 -->
    <div id='map'></div>

    <!-- 사용자 인터페이스 영역 -->
    <div id="interface" onmouseout="mouseOverInterface(false);" onmouseover="mouseOverInterface(true);">
        <!-- 레이어 열기 버튼 -->
        <button id="openLayer">Open</button>
    </div>

    <div id="geojsonLayerList" class="layerlist" style="margin-bottom: 10px;"></div>

    <script>
        index = 0;
        // 랜덤 색상 생성 함수
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Electron에서 파일 경로 수신 시 처리
        window.electronAPI.onFilePathReceived((event, filePaths) => {
            // 여러 파일을 받을 수 있도록 filePaths 배열로 처리
            if (!Array.isArray(filePaths)) {
                filePaths = [filePaths];
            }
            filePaths.forEach((filePath) => {
                // 파일 경로에서 file:/// 접두어 제거
                if (filePath.startsWith("file:///")) {
                    filePath = filePath.replace("file:///", "");
                } else if (filePath.startsWith("File:///")) {
                    filePath = filePath.replace("File:///", "");
                }
                filePath = filePath.replace(/\\/g, '/'); // 역슬래시를 슬래시로 변경

                if (filePath.endsWith('tileset.json')) {
                    

                    // tileset.json 파일이면 3DTILES 레이어로 추가
                    let layerList = new Module.JSLayerList(true);
                    // 상위 폴더명 추출
                    let pathParts = filePath.split(/[\\/]/);
                    let parentFolder = pathParts.length > 1 ? pathParts[pathParts.length - 2] : '_LAYER_' + index;
                    let layer = layerList.createLayer(parentFolder, Module.ELT_3DTILES);
                    layer.import3DTiles({
                        url: filePath,
                        autoMove: true,
                        offsetZ: 2.0
                    });
                    layer.setPointCloudPointSize(1); // 포인트 클라우드 크기 설정

                    // 새 레이어 UI 생성
                    const layerItem = document.createElement('div');
                    layerItem.className = 'layer-item';

                    // 체크박스
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.addEventListener('change', () => {
                        layer.setVisible(checkbox.checked);
                    });

                    // 레이어 이름
                    const label = document.createElement('span');
                    label.textContent = parentFolder;
                    label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                    label.addEventListener('click', () => {
                        const jsonData = window.electronAPI.readJsonFile(filePath);
                        var trs = jsonData['root']['transform'];
                        var lla = ecefToLla(trs[12], trs[13], trs[14]);
                        Module.getViewCamera().move(new Module.JSVector3D(lla.lonDeg, lla.latDeg, lla.h + 1000), 89.9, 0, 0);

                    });

                    // x 제거 버튼
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = "X";
                    removeBtn.addEventListener('click', () => {
                        Module.XDEMapRemoveLayer(label.textContent);
                        layerItem.remove();
                        mouseOverInterface(false);
                    });

                    // 조립
                    layerItem.appendChild(checkbox);
                    layerItem.appendChild(label);
                    layerItem.appendChild(removeBtn);
                    document.getElementById('interface').appendChild(layerItem);
                    index++;
                } else if (filePath.endsWith('.geojson')) {
                    loadGeojsonLayer(filePath);
                } else if (filePath.endsWith('.meta')) {
                    loadMetaLayer(filePath);
                }
            });
        });

        // 파일 선택 버튼 클릭 시 메인 프로세스에 파일 선택 요청
        document.getElementById('openLayer').addEventListener('click', async () => {

            window.electronAPI.openFileDialog({
                filters: [
                    { name: 'JSON/GeoJSON Files', extensions: ['json', 'geojson'] },
                    { name: 'Layer', extensions: ['meta'] }
                ],
                properties: ['openFile']
            }); // 메인 프로세스의 파일 선택 다이얼로그 호출
        });

        // 인터페이스 마우스 오버 상태 설정
        function mouseOverInterface(_isOver) {
            if (typeof Module == "object") {
                Module.XDIsMouseOverDiv(_isOver);
            }
        }

        // 창 크기 변경 시 처리
        window.onresize = function (e) {
            if (typeof Module == 'object') {
                if (typeof Module.Resize == 'function') {
                    Module.Resize(window.innerWidth, window.innerHeight); // 모듈 크기 조정
                    Module.XDRenderData(); // 데이터 렌더링
                }
            }
        };

        // XDWorld 모듈 설정
        var Module = {
            locateFile: function (s) {
                return "https://cdn.xdworld.kr/latest/" + s; // 모듈 파일 경로 설정
            },
            postRun: function () {
                Module.initialize({
                    container: document.getElementById("map"), // 지도 컨테이너 설정
                    terrain: {
                        dem: {
                            url: "https://xdworld.vworld.kr",
                            name: "dem",
                            servername: "XDServer3d",
                            encoding: true
                        },
                        image: {
                            url: "https://xdworld.vworld.kr",
                            name: "tile",
                            servername: "XDServer3d"
                        }
                    },
                    worker: {
                        use: true, // 워커 사용 여부
                        path: "./worker/XDWorldWorker.js", // 워커 파일 경로
                        count: 5 // 워커 수
                    },
                    defaultKey: "dJe!e!iaEpHmEpCrD5QpEQf2#FBrdzDmd(BQDQEQDJdaE(iB"
                });
                /*
                                // 기본 타일 레이어 설정
                                var layerSimple = Module.getTileLayerList().createXDServerLayer({
                                    url: "https://xdworld.vworld.kr",
                                    servername: "XDServer3d",
                                    name: "facility_build",
                                    type: 9,
                                    minLevel: 0,
                                    maxLevel: 15
                                });
                                Module.setVisibleRange("facility_build", 3.0, 100000.0); // 가시 범위 설정
                
                                // 간단 모드 설정
                                Module.getMap().setSimpleMode(true);
                                Module.getViewCamera().setLocation(new Module.JSVector3D(126.9, 37.5, 300.0)); // 초기 카메라 위치 설정
                                Module.getViewCamera().setTilt(30); // 카메라 기울기 설정
                */
            }
        };

        // XDWorld 스크립트 동적 로드
        var script = document.createElement('script');
        script.src = "https://cdn.xdworld.kr/latest/XDWorldEM.js";
        document.body.appendChild(script);

        function createPointObjects(layer, features, altitude, color) {
            var layerName = layer.getName();
            var pointIcon = getMarkerIcon(layerName, color, false, 0);

            for (let i = 0; i < features.length; i++) {
                let feature = features[i];
                let coords = feature.geometry.coordinates;
                if (!Array.isArray(coords) || coords.length < 2) continue;
                if (!pointIcon) {
                    console.error("아이콘 생성 실패");
                    return;
                }
                let id = feature.id || "GEOJSON_POINT_" + i;
                let lon = coords[0];
                let lat = coords[1];
                let alt = coords.length >= 3 ? coords[2] : altitude;

                let point = Module.createPoint(id);
                point.setPosition(new Module.JSVector3D(lon, lat, alt + 1.5));
                point.setIcon(pointIcon)


                layer.addObject(point, 0);
            }
            layer.rebuildObjectLayer();
        }

        function createLineObjects(layer, features, altitude, color) {
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                const geometry = feature.geometry;
                if (!geometry || !geometry.coordinates) continue;

                const id = feature.id || `GEOJSON_LINE_${i}`;
                const line = Module.createLineString(id);

                const vertexList = new Module.JSVec3Array();
                const partList = new Module.Collection();

                if (geometry.type === "LineString") {
                    partList.addItem(geometry.coordinates.length);
                    geometry.coordinates.forEach(coord => {
                        const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                        vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                    });
                }
                else if (geometry.type === "MultiLineString") {
                    for (const part of geometry.coordinates) {
                        partList.add(part.length);
                        for (const coord of part) {
                            const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                            vertexList.push(new Module.JSVector3D(x, y, z + 1.5));
                        }
                    }
                }
                // 스타일 지정
                var style = new Module.JSPolyLineStyle();
                style.setWidth(3.0);
                style.setColor(new Module.JSColor(255, ...colorStringToRGB(color)));
                line.setStyle(style);

                line.setPartCoordinates(vertexList, partList);
                layer.addObject(line, 0);
            }
            layer.rebuildObjectLayer();
        }

        function createPolygonObjects(layer, features, altitude, color) {
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                const geometry = feature.geometry;
                if (!geometry || !geometry.coordinates) continue;

                const id = feature.id || `GEOJSON_POLY_${i}`;

                if (geometry.type === "Polygon") {
                    createSinglePolygon(id, geometry.coordinates, color, altitude, layer);
                }
                else if (geometry.type === "MultiPolygon") {
                    for (let j = 0; j < geometry.coordinates.length; j++) {
                        const partId = `${id}_part${j}`;
                        createSinglePolygon(partId, geometry.coordinates[j], color, altitude, layer);
                    }
                }
            }
            layer.rebuildObjectLayer();
        }

        function createSinglePolygon(id, rings, color, altitude, layer) {
            const polygon = Module.createPolygon(id);
            const allVertices = new Module.Collection();

            // 외곽선만 추가 (내부 링은 무시)
            const outerRing = rings[0];
            outerRing.forEach(coord => {
                const x = coord[0], y = coord[1], z = coord[2] ?? altitude;
                allVertices.add(new Module.JSVector3D(x, y, z + 1.5));
            });

            const style = new Module.JSPolygonStyle();
            style.setFill(true);
            style.setFillColor(new Module.JSColor(255, ...colorStringToRGB(color)));

            polygon.setStyle(style);
            polygon.setCoordinates(allVertices);

            layer.addObject(polygon, 0);
        }

        function colorStringToRGB(rgbaStr) {
            // 예: "rgba(123, 234, 45, 1.0)" → [123, 234, 45]
            const matches = rgbaStr.match(/\d+(\.\d+)?/g);
            if (!matches || matches.length < 3) return [0, 0, 0];
            return [parseInt(matches[0]), parseInt(matches[1]), parseInt(matches[2])];
        }

        function getMarkerIcon(_id, _color, returnDataUrl, type) {
            var canvas = document.createElement('canvas');
            var size = 16;
            canvas.width = size;
            canvas.height = size;

            var ctx = canvas.getContext('2d');

            if (type == 0) {
                // 점
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 4, 0, 2 * Math.PI, false);
                ctx.fillStyle = _color;
                ctx.fill();
            } else if (type == 1) {
                // 선
                ctx.beginPath();
                ctx.moveTo(0, size / 2);
                ctx.lineTo(size, size / 2);
                ctx.strokeStyle = _color;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                // 면
                ctx.beginPath();
                ctx.moveTo(2, 2);
                ctx.lineTo(size - 2, 2);
                ctx.lineTo(size - 2, size - 2);
                ctx.lineTo(2, size - 2);
                ctx.closePath();

                ctx.fillStyle = _color;
                ctx.fill();
                ctx.strokeStyle = "#FFFFFF"; // 테두리 색 (옵션)
                ctx.lineWidth = 1;
                ctx.stroke();
            }


            if (returnDataUrl) {
                return canvas.toDataURL();
            }

            if (Module.getSymbol().insertIcon(_id, ctx.getImageData(0, 0, canvas.width, canvas.height).data, canvas.width, canvas.height)) {
                return Module.getSymbol().getIcon(_id);
            }
            return null;
        }



        function loadGeojsonLayer(filePath) {
            const fileName = filePath.split(/[\/]/).pop().replace('.geojson', '');
            window.electronAPI.readGeoJSON(filePath).then(function (data) {
                if (!data || !data.features || data.features.length === 0) {
                    alert("GeoJSON에 feature가 없습니다.");
                    return;
                }
                const type = data.features[0].geometry.type;
                const layerList = new Module.JSLayerList(true);
                let layer = null;
                switch (type) {
                    case "Point":
                        layer = layerList.createLayer(fileName, Module.ELT_3DPOINT);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        layer = layerList.createLayer(fileName, Module.ELT_3DLINE);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        layer = layerList.createLayer(fileName, Module.ELT_POLYHEDRON);
                        break;
                    default:
                        alert("지원하지 않는 geometry type: " + type);
                        return;
                }
                // 랜더러에서 파싱된 데이터 사용
                const randomColor = 'rgba(' + Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ',' +
                    Math.floor(Math.random() * 256) + ', 1.0)';
                switch (type) {
                    case "Point":
                        createPointObjects(layer, data.features, 0.0, randomColor);
                        break;
                    case "LineString":
                    case "MultiLineString":
                        createLineObjects(layer, data.features, 0.0, randomColor);
                        break;
                    case "Polygon":
                    case "MultiPolygon":
                        createPolygonObjects(layer, data.features, 0.0, randomColor);
                        break;
                }
                // 새 레이어 UI 생성
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';

                // 체크박스
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    layer.setVisible(checkbox.checked);
                });

                // geometry 타입에 따른 아이콘
                let iconElement = null;
                if (type === "Point") {
                    // 지도용: getPointMarkerIcon(fileName, randomColor)
                    // 리스트용: getPointMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 0);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '12px';
                    iconElement.style.height = '12px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';
                    //iconElement.innerHTML = `<div style="position:relative;top:7px;left:2px;width:3px;height:3px;background:${randomColor};border-radius:1px;"></div>`;
                } else if (type === "LineString" || type === "MultiLineString") {
                    // 지도용: getLineMarkerIcon(fileName, randomColor)
                    // 리스트용: getLineMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 1);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '12px';
                    iconElement.style.height = '12px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';
                } else if (type === "Polygon" || type === "MultiPolygon") {
                    // 지도용: getPolygonMarkerIcon(fileName, randomColor)
                    // 리스트용: getPolygonMarkerIcon(fileName, randomColor, true)
                    const iconUrl = getMarkerIcon(fileName, randomColor, true, 2);
                    iconElement = document.createElement('img');
                    iconElement.src = iconUrl;
                    iconElement.style.width = '16px';
                    iconElement.style.height = '16px';
                    //iconElement.style.position = 'relative';
                    //iconElement.style.margin = '0 4 16 0px';                    
                }

                moveToLayer(layer)

                // 레이어 이름
                const label = document.createElement('span');
                label.textContent = fileName;
                label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                label.addEventListener('click', () => {
                    moveToLayer(layer)
                });

                // x 제거 버튼
                const removeBtn = document.createElement('button');
                removeBtn.textContent = "X";
                removeBtn.addEventListener('click', () => {
                    Module.XDEMapRemoveLayer(label.textContent);
                    layerItem.remove();
                    mouseOverInterface(false);
                });

                // 조립
                layerItem.appendChild(checkbox);
                if (iconElement) {
                    layerItem.appendChild(iconElement);
                }
                layerItem.appendChild(label);
                layerItem.appendChild(removeBtn);
                document.getElementById('interface').appendChild(layerItem);
                index++;
            }).catch(err => {
                alert("GeoJSON 파일을 읽을 수 없습니다: " + err);
            });
        }
        function moveToLayer(layer) {
            let obj = layer.indexAtObject(0);
            console.log(obj.position.longitude, obj.position.latitude, obj.position.altitude);
            let cenLon = obj.position.longitude;
            let cenLat = obj.position.latitude;
            let cenAlt = obj.position.altitude;
            Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, cenAlt + 1000), 89.9, 0, 0);

        }
        // ECEF -> Geodetic (lat, lon, h), WGS84
        function ecefToLla(x, y, z) {
            const a = 6378137.0;                 // WGS84 semi-major
            const f = 1 / 298.257223563;         // flattening
            const e2 = f * (2 - f);              // first eccentricity^2

            const lon = Math.atan2(y, x);
            const p = Math.hypot(x, y);
            let lat = Math.atan2(z, p * (1 - e2));
            let N, h, latNew;

            for (let i = 0; i < 10; i++) {
                const sinLat = Math.sin(lat);
                N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                h = p / Math.cos(lat) - N;
                latNew = Math.atan2(z, p * (1 - e2 * N / (N + h)));
                if (Math.abs(lat - latNew) < 1e-12) { lat = latNew; break; }
                lat = latNew;
            }
            N = a / Math.sqrt(1 - e2 * Math.sin(lat) ** 2);
            h = p / Math.cos(lat) - N;

            return {
                latDeg: lat * 180 / Math.PI,
                lonDeg: lon * 180 / Math.PI,
                h
            };
        }
        function loadMetaLayer(filePath) {
            window.electronAPI.readMeta(filePath)
                .then(data => {
                    try {

                        const jsonData = JSON.parse(data);
                        const layerName = jsonData['name'];
                        const layerPath = jsonData['path'];
                        const layerType = jsonData['type'];
                        const minLon = jsonData['area']['min']['lon'];
                        const maxLon = jsonData['area']['max']['lon'];
                        const minLat = jsonData['area']['min']['lat'];
                        const maxLat = jsonData['area']['max']['lat'];
                        const minLv = jsonData['level']['min'];
                        const maxLv = jsonData['level']['max'];
                        let cenLon = (minLon + maxLon) / 2;
                        let cenLat = (minLat + maxLat) / 2;

                        let layer = null;
                        let layerList = new Module.JSLayerList(false);
                        if (layerType == "ETLT_PNG_IMAGE") {                            
                            Module.XDEMapCreateLayer(layerName, layerPath, 0, true, true, true, Module.ELT_TERRAIN_IMAGE, minLv, maxLv);
                            Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, 5000), 89.9, 0, 0);
                            layer = layerList.nameAtLayer(layerName);
                        }else if(layerType == "ETLT_VECTOR_PIPE") {
                            Module.XDEMapCreateLayer(layerName, layerPath, 0, true, true, true, Module.ELT_PIPE, minLv, maxLv);
                            Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, 5000), 89.9, 0, 0);
                            layer = layerList.nameAtLayer(layerName);
                            Module.XDESetPlanetTransparecny(0.5);
                        }

                        if (layer != null) {
                            console.log(layer);
                            const layerItem = document.createElement('div');
                            layerItem.className = 'layer-item';

                            // 체크박스
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', () => {
                                layer.setVisible(checkbox.checked);
                            });

                            // 레이어 이름
                            const label = document.createElement('span');
                            label.textContent = layerName;
                            label.style.cursor = 'pointer'; // 클릭 가능함을 표시
                            label.addEventListener('click', () => {
                                // 레이어 클릭시 동작
                                Module.getViewCamera().move(new Module.JSVector3D(cenLon, cenLat, 5000), 89.9, 0, 0);
                            });

                            // x 제거 버튼
                            const removeBtn = document.createElement('button');
                            removeBtn.textContent = 'X';
                            removeBtn.addEventListener('click', () => {
                                Module.XDEMapRemoveLayer(label.textContent);
                                layerItem.remove();
                                mouseOverInterface(false);
                            });

                            // 조립
                            layerItem.appendChild(checkbox);
                            layerItem.appendChild(label);
                            layerItem.appendChild(removeBtn);
                            document.getElementById('interface').appendChild(layerItem);
                            index++;
                        }
                    } catch (e) {
                        console.error("Failed to parse .meta file as JSON:", e);
                        alert(".meta 파일을 JSON으로 파싱하는데 실패했습니다.");
                    }
                })
                .catch(err => {
                    console.error("Failed to read .meta file:", err);
                    alert(".meta 파일을 읽는데 실패했습니다.");
                });
        }



    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
</body>

</html>